/**
 * ã‚¹ãƒ—ãƒ¬ãƒƒãƒ‰ã‚·ãƒ¼ãƒˆã®ã‚¿ã‚¹ã‚¯ç®¡ç†ï¼†ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆã‚·ãƒ¼ãƒˆè‡ªå‹•ä½œæˆã‚¹ã‚¯ãƒªãƒ—ãƒˆï¼ˆå®Œå…¨ç‰ˆï¼‰
 * * ã€æ©Ÿèƒ½ä¸€è¦§ã€‘
 * 1. ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆä¸€è¦§ã‚·ãƒ¼ãƒˆã®Aåˆ—ã«å…¥åŠ› -> è¨­å®šã‚·ãƒ¼ãƒˆå·¦å´ã«ãƒ†ãƒ³ãƒ—ãƒ¬ãƒ¼ãƒˆã‚’ã‚³ãƒ”ãƒ¼ã—ã¦æ–°ã‚·ãƒ¼ãƒˆä½œæˆ
 * 2. ã‚¿ã‚¹ã‚¯å…¥åŠ›ã‚·ãƒ¼ãƒˆ(5è¡Œç›®~)ãŠã‚ˆã³å„ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆã‚·ãƒ¼ãƒˆ(29è¡Œç›®~)ã®Cåˆ—ã«å…¥åŠ› -> IDè‡ªå‹•ç”Ÿæˆ
 * 3. ã€å¾©æ´»ã€‘ã‚¿ã‚¹ã‚¯å…¥åŠ›ã‚·ãƒ¼ãƒˆã®Aåˆ—(å®Œäº†)ã‚’ON -> ã€Œå®Œäº†ã‚¿ã‚¹ã‚¯ã€ã‚·ãƒ¼ãƒˆã¸ç§»å‹•
 * 4. ã€å¾©æ´»ã€‘å„ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆã‚·ãƒ¼ãƒˆã®Aåˆ—(å®Œäº†)ã‚’ON -> åŒã‚·ãƒ¼ãƒˆå†…ã®ã‚¢ãƒ¼ã‚«ã‚¤ãƒ–ã‚¨ãƒªã‚¢ã¸ç§»å‹•
 * 5. ã‚¿ã‚¹ã‚¯å…¥åŠ›ã‚·ãƒ¼ãƒˆã®F3ãƒã‚§ãƒƒã‚¯ãƒœãƒƒã‚¯ã‚¹ON -> ã€çµ±åˆæ©Ÿèƒ½ã€‘åŒæœŸãƒ»è»¢é€ãƒ»ä¸¦ã³æ›¿ãˆã‚’ä¸€æ‹¬å®Ÿè¡Œ
 * 6. å€‹åˆ¥ã®ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆã‚·ãƒ¼ãƒˆã§E2ãƒã‚§ãƒƒã‚¯ãƒœãƒƒã‚¯ã‚¹ON -> ã‚«ãƒ¬ãƒ³ãƒ€ãƒ¼åŒæœŸ ï¼† ä¸¦ã³æ›¿ãˆ
 * 7. ã€Œã‚¿ã‚¹ã‚¯ä¸€è¦§ã€ã‚·ãƒ¼ãƒˆã®D1ãƒã‚§ãƒƒã‚¯ãƒœãƒƒã‚¯ã‚¹ON -> ã€çµ±åˆæ©Ÿèƒ½ã€‘ã‚«ãƒ¬ãƒ³ãƒ€ãƒ¼åæ˜ å¾Œã«ç›´è¿‘ã‚¿ã‚¹ã‚¯ã‚’é›†è¨ˆãƒ»æ›´æ–°
 * - æœªè¨­å®šã‚¿ã‚¹ã‚¯ï¼ˆå³å´ï¼‰ã®æ—¥æ™‚å…¥åŠ› -> ã‚«ãƒ¬ãƒ³ãƒ€ãƒ¼ç™»éŒ²
 * - ç¢ºå®šã‚¿ã‚¹ã‚¯ï¼ˆå·¦å´ï¼‰ã®å¤‰æ›´ -> ã‚«ãƒ¬ãƒ³ãƒ€ãƒ¼åæ˜ 
 * - ã‚«ãƒ¬ãƒ³ãƒ€ãƒ¼å´ã®å¤‰æ›´ -> ã‚·ãƒ¼ãƒˆåæ˜ 
 * - æ‰€è¦æ™‚é–“ãƒ—ãƒ«ãƒ€ã‚¦ãƒ³ã®è¨­å®šã‚·ãƒ¼ãƒˆå‚ç…§
 * * * * * ã€é‡è¦: æœ€åˆã«å¿…ãšå®Ÿè¡Œã—ã¦ãã ã•ã„ã€‘
 * ãƒ¡ãƒ‹ãƒ¥ãƒ¼ã®ã€ŒğŸ“… ã‚¿ã‚¹ã‚¯é€£æºã€>ã€Œè¨­å®š: è‡ªå‹•åŒ–ãƒˆãƒªã‚¬ãƒ¼ã‚’ã‚»ãƒƒãƒˆã€ã‚’å®Ÿè¡Œã—ã¦æ©Ÿèƒ½ã‚’æœ‰åŠ¹åŒ–ã—ã¦ãã ã•ã„ã€‚
 */


// ==========================================
// ã€è¿½è¨˜ã€‘èªè¨¼é–€ç•ªã‚·ã‚¹ãƒ†ãƒ ï¼ˆWebã‚¢ãƒ—ãƒªç”¨ï¼‰
// ==========================================

/**
 * å¤–éƒ¨ã‹ã‚‰ã®èªè¨¼ãƒªã‚¯ã‚¨ã‚¹ãƒˆã‚’å—ã‘å–ã‚‹ï¼ˆâ–¶å®Ÿè¡Œãƒœã‚¿ãƒ³ã¯æŠ¼ã—ã¡ã‚ƒãƒ€ãƒ¡ï¼ï¼‰
 */
function doGet(e) {
  // â˜…é‡è¦: ã‚¨ãƒ‡ã‚£ã‚¿ã®ã€Œå®Ÿè¡Œã€ãƒœã‚¿ãƒ³ã‚’æŠ¼ã—ãŸã¨ãã®å¯¾ç­–
  if (!e) {
    return ContentService.createTextOutput("ã€ã‚¨ãƒ©ãƒ¼ã€‘ã“ã®é–¢æ•°ã¯ã€Œã‚¦ã‚§ãƒ–ã‚¢ãƒ—ãƒªã€ã¨ã—ã¦ãƒ‡ãƒ—ãƒ­ã‚¤ã—ã¦ä½¿ã†ã‚‚ã®ã§ã™ã€‚ã“ã“ã§ã®å®Ÿè¡Œãƒœã‚¿ãƒ³ã§ã¯å‹•ä½œã—ã¾ã›ã‚“ã€‚");
  }

  const userEmail = e.parameter ? e.parameter.email : null;
  const ss = SpreadsheetApp.getActiveSpreadsheet();
  const sheet = ss.getSheetByName("èªè¨¼ãƒªã‚¹ãƒˆ"); // ã‚·ãƒ¼ãƒˆåãŒç”»åƒã¨ä¸€è‡´ã—ã¦ã„ã‚‹ã“ã¨
  
  if (!sheet) {
    return ContentService.createTextOutput("Error: 'èªè¨¼ãƒªã‚¹ãƒˆ' sheet not found");
  }
  
  // 1è¡Œç›®ï¼ˆè¦‹å‡ºã—ï¼‰ã‚’é£›ã°ã—ã€2è¡Œç›®ä»¥é™ã®ã€ŒCåˆ—ï¼ˆ3åˆ—ç›®ï¼‰ã€ã‚’ã™ã¹ã¦å–å¾—
  const lastRow = sheet.getLastRow();
  if (lastRow < 2) return ContentService.createTextOutput("NG");
  
  const authEmails = sheet.getRange(2, 3, lastRow - 1, 1).getValues().flat();

  // å®Ÿéš›ã«ãƒ„ãƒ¼ãƒ«ã‚’ä½¿ã£ã¦ã„ã‚‹äººã®ã‚¢ãƒ‰ãƒ¬ã‚¹ãŒå«ã¾ã‚Œã¦ã„ã‚‹ã‹åˆ¤å®š
  const isAllowed = authEmails.includes(userEmail);
  return ContentService.createTextOutput(isAllowed ? "OK" : "NG");
}

/**
 * ã‚¹ãƒ—ãƒ¬ãƒƒãƒ‰ã‚·ãƒ¼ãƒˆã®ã‚¿ã‚¹ã‚¯ç®¡ç†ï¼†ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆã‚·ãƒ¼ãƒˆè‡ªå‹•ä½œæˆã‚¹ã‚¯ãƒªãƒ—ãƒˆï¼ˆå®Œå…¨ç‰ˆï¼‰
 * * ã€æ©Ÿèƒ½ä¸€è¦§ã€‘
 * 1. ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆä¸€è¦§ã‚·ãƒ¼ãƒˆã®Aåˆ—ã«å…¥åŠ› -> è¨­å®šã‚·ãƒ¼ãƒˆå·¦å´ã«ãƒ†ãƒ³ãƒ—ãƒ¬ãƒ¼ãƒˆã‚’ã‚³ãƒ”ãƒ¼ã—ã¦æ–°ã‚·ãƒ¼ãƒˆä½œæˆ
 * 2. ã‚¿ã‚¹ã‚¯å…¥åŠ›ã‚·ãƒ¼ãƒˆ(5è¡Œç›®~)ãŠã‚ˆã³å„ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆã‚·ãƒ¼ãƒˆ(29è¡Œç›®~)ã®Cåˆ—ã«å…¥åŠ› -> IDè‡ªå‹•ç”Ÿæˆ
 * 3. ã€å¾©æ´»ã€‘ã‚¿ã‚¹ã‚¯å…¥åŠ›ã‚·ãƒ¼ãƒˆã®Aåˆ—(å®Œäº†)ã‚’ON -> ã€Œå®Œäº†ã‚¿ã‚¹ã‚¯ã€ã‚·ãƒ¼ãƒˆã¸ç§»å‹•
 * 4. ã€å¾©æ´»ã€‘å„ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆã‚·ãƒ¼ãƒˆã®Aåˆ—(å®Œäº†)ã‚’ON -> åŒã‚·ãƒ¼ãƒˆå†…ã®ã‚¢ãƒ¼ã‚«ã‚¤ãƒ–ã‚¨ãƒªã‚¢ã¸ç§»å‹•
 * 5. ã‚¿ã‚¹ã‚¯å…¥åŠ›ã‚·ãƒ¼ãƒˆã®F3ãƒã‚§ãƒƒã‚¯ãƒœãƒƒã‚¯ã‚¹ON -> ã€çµ±åˆæ©Ÿèƒ½ã€‘åŒæœŸãƒ»è»¢é€ãƒ»ä¸¦ã³æ›¿ãˆã‚’ä¸€æ‹¬å®Ÿè¡Œ
 * 6. å€‹åˆ¥ã®ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆã‚·ãƒ¼ãƒˆã§E2ãƒã‚§ãƒƒã‚¯ãƒœãƒƒã‚¯ã‚¹ON -> ã‚«ãƒ¬ãƒ³ãƒ€ãƒ¼åŒæœŸ ï¼† ä¸¦ã³æ›¿ãˆ
 * 7. ã€Œã‚¿ã‚¹ã‚¯ä¸€è¦§ã€ã‚·ãƒ¼ãƒˆã®D1ãƒã‚§ãƒƒã‚¯ãƒœãƒƒã‚¯ã‚¹ON -> ã€çµ±åˆæ©Ÿèƒ½ã€‘ã‚«ãƒ¬ãƒ³ãƒ€ãƒ¼åæ˜ å¾Œã«ç›´è¿‘ã‚¿ã‚¹ã‚¯ã‚’é›†è¨ˆãƒ»æ›´æ–°
 * - æœªè¨­å®šã‚¿ã‚¹ã‚¯ï¼ˆå³å´ï¼‰ã®æ—¥æ™‚å…¥åŠ› -> ã‚«ãƒ¬ãƒ³ãƒ€ãƒ¼ç™»éŒ²
 * - ç¢ºå®šã‚¿ã‚¹ã‚¯ï¼ˆå·¦å´ï¼‰ã®å¤‰æ›´ -> ã‚«ãƒ¬ãƒ³ãƒ€ãƒ¼åæ˜ 
 * - ã‚«ãƒ¬ãƒ³ãƒ€ãƒ¼å´ã®å¤‰æ›´ -> ã‚·ãƒ¼ãƒˆåæ˜ 
 * - æ‰€è¦æ™‚é–“ãƒ—ãƒ«ãƒ€ã‚¦ãƒ³ã®è¨­å®šã‚·ãƒ¼ãƒˆå‚ç…§
 * * * * * ã€é‡è¦: æœ€åˆã«å¿…ãšå®Ÿè¡Œã—ã¦ãã ã•ã„ã€‘
 * ãƒ¡ãƒ‹ãƒ¥ãƒ¼ã®ã€ŒğŸ“… ã‚¿ã‚¹ã‚¯é€£æºã€>ã€Œè¨­å®š: è‡ªå‹•åŒ–ãƒˆãƒªã‚¬ãƒ¼ã‚’ã‚»ãƒƒãƒˆã€ã‚’å®Ÿè¡Œã—ã¦æ©Ÿèƒ½ã‚’æœ‰åŠ¹åŒ–ã—ã¦ãã ã•ã„ã€‚
 */

// --- è¨­å®šå€¤ ---
const PROJECT_SHEET_NAME = 'ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆä¸€è¦§';
const TEMPLATE_SHEET_NAME = 'ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆãƒ†ãƒ³ãƒ—ãƒ¬ãƒ¼ãƒˆ';
const TASK_SHEET_NAME = 'ã‚¿ã‚¹ã‚¯å…¥åŠ›';
const SETTING_SHEET_NAME = 'è¨­å®š';
const COMPLETED_SHEET_NAME = 'å®Œäº†ã‚¿ã‚¹ã‚¯';
const RECENT_TASK_SHEET_NAME = 'ã‚¿ã‚¹ã‚¯ä¸€è¦§';
const CALENDAR_INBOX_SHEET_NAME = 'ã‚«ãƒ¬ãƒ³ãƒ€ãƒ¼å–è¾¼';
const GAS_MANAGE_SHEET_NAME = 'gasç®¡ç†';


// ã‚¿ã‚¹ã‚¯å…¥åŠ›ã‚·ãƒ¼ãƒˆè¨­å®š
const TASK_START_ROW = 5;   // ã‚¿ã‚¹ã‚¯å…¥åŠ›ã‚·ãƒ¼ãƒˆã®å…¥åŠ›é–‹å§‹è¡Œ
const PROJECT_TASK_START_ROW = 29; // ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆã‚·ãƒ¼ãƒˆã®ã‚¿ã‚¹ã‚¯é–‹å§‹è¡Œ
 
const COL_TASK_NAME = 2;    // Båˆ— (æ—§Cåˆ—)
const COL_START_TIME = 3;   // Cåˆ— (æ—§Dåˆ—)
const COL_PRIORITY = 4;     // Dåˆ— (æ—§Eåˆ—)
const COL_DURATION = 5;     // Eåˆ— (æ—§Fåˆ—)
const COL_PROJECT_NAME = 6; // Fåˆ— (æ—§Gåˆ—)
const COL_CAL_TYPE = 9;     // Iåˆ— (æ—§Jåˆ—)
const COL_EVENT_ID = 10;    // Jåˆ— (æ—§Kåˆ—)
const COL_TASK_ID = 11;     // Kåˆ— (æ—§Låˆ—)
 
// ã‚¨ãƒªã‚¢å®šç¾©
const TASK_AREA_LAST_COL = 12; // Låˆ—ã¾ã§ã‚’ã‚¿ã‚¹ã‚¯ã‚¨ãƒªã‚¢ã¨ã™ã‚‹
const ARCHIVE_START_ROW = 29;  // ã‚¢ãƒ¼ã‚«ã‚¤ãƒ–é–‹å§‹è¡Œ
const ARCHIVE_START_COL = 13;  // Måˆ—ã‹ã‚‰ã‚¢ãƒ¼ã‚«ã‚¤ãƒ–
 
// ã‚¹ãƒãƒ›æ“ä½œç”¨ãƒã‚§ãƒƒã‚¯ãƒœãƒƒã‚¯ã‚¹ã®ä½ç½®
const SYNC_CHECKBOX_CELL = 'E2';        // ã‚¿ã‚¹ã‚¯å…¥åŠ›ã‚·ãƒ¼ãƒˆç”¨ (F2 -> E2)
const EXECUTE_ALL_CHECKBOX_CELL = 'A3'; // ã‚¿ã‚¹ã‚¯å…¥åŠ›ã‚·ãƒ¼ãƒˆç”¨ (E3 -> A3)
const PROJECT_SYNC_SORT_CELL = 'A27';   // ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆã‚·ãƒ¼ãƒˆç”¨ (D2 -> A27)
const DASHBOARD_INTEGRATED_CHECKBOX_CELL = 'D1'; // ã‚¿ã‚¹ã‚¯ä¸€è¦§ã‚·ãƒ¼ãƒˆç”¨ (å¤‰æ›´ãªã—)
const CALENDAR_IMPORT_CHECKBOX_CELL = 'F1';  // ã‚¿ã‚¹ã‚¯ä¸€è¦§ã‚·ãƒ¼ãƒˆç”¨ (å¤‰æ›´ãªã—)

// è¨­å®šã‚·ãƒ¼ãƒˆåˆ—å®šç¾©
const SETTINGS_NAME_COL = 2;
const SETTINGS_ID_COL = 3;
const SETTINGS_DURATION_COL = 5; // Eåˆ—: æ‰€è¦æ™‚é–“ãƒªã‚¹ãƒˆ

// å‡¦ç†ã‹ã‚‰é™¤å¤–ã™ã‚‹ã‚·ãƒ¼ãƒˆåãƒªã‚¹ãƒˆ
const EXCLUDED_SHEETS = [
  PROJECT_SHEET_NAME, 
  TEMPLATE_SHEET_NAME, 
  TASK_SHEET_NAME, 
  SETTING_SHEET_NAME, 
  COMPLETED_SHEET_NAME,
  RECENT_TASK_SHEET_NAME,
  RECENT_TASK_SHEET_NAME,
  CALENDAR_INBOX_SHEET_NAME,
  GAS_MANAGE_SHEET_NAME,

];


/**
 * ãƒ¡ãƒ‹ãƒ¥ãƒ¼è¿½åŠ 
 */
function onOpen() {
  const ui = SpreadsheetApp.getUi();
  ui.createMenu('ğŸ“… ã‚¿ã‚¹ã‚¯é€£æº')
    .addItem('è¨­å®š: è‡ªå‹•åŒ–ãƒˆãƒªã‚¬ãƒ¼ã‚’ã‚»ãƒƒãƒˆ (æ›´æ–°æ™‚ã‚‚å®Ÿè¡Œ)', 'setupTriggers')
    .addSeparator()
    .addItem('æ‰‹å‹•: ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆã‚·ãƒ¼ãƒˆä½œæˆ', 'createProjectSheets')
    .addItem('æ‰‹å‹•: ã‚«ãƒ¬ãƒ³ãƒ€ãƒ¼åŒæœŸ (ã‚¿ã‚¹ã‚¯å…¥åŠ›)', 'syncTasksToCalendar')
    .addItem('æ‰‹å‹•: ã€çµ±åˆã€‘åŒæœŸãƒ»è»¢é€ãƒ»ä¸¦ã³æ›¿ãˆ (ã‚¿ã‚¹ã‚¯å…¥åŠ›)', 'executeTasksAction')
    .addItem('æ‰‹å‹•: ã‚¿ã‚¹ã‚¯ä¸€è¦§æ›´æ–° (çµ±åˆç‰ˆ)', 'updateDashboardWithCalendarSync')
    .addToUi();
}

/**
 * ã€é‡è¦ã€‘ãƒˆãƒªã‚¬ãƒ¼è¨­å®šç”¨é–¢æ•°
 */
function setupTriggers() {
  const triggers = ScriptApp.getProjectTriggers();
  triggers.forEach(t => ScriptApp.deleteTrigger(t));

  ScriptApp.newTrigger('onEditTrigger')
    .forSpreadsheet(SpreadsheetApp.getActive())
    .onEdit()
    .create();

  ScriptApp.newTrigger('syncTasksToCalendar')
    .timeBased()
    .everyMinutes(5)
    .create();

  Browser.msgBox('è¨­å®šå®Œäº†ï¼\nãƒˆãƒªã‚¬ãƒ¼ã‚’æ›´æ–°ã—ã¾ã—ãŸã€‚å¿…ãšã“ã®ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ãŒè¡¨ç¤ºã•ã‚ŒãŸã“ã¨ã‚’ç¢ºèªã—ã¦ãã ã•ã„ã€‚');
}

/**
 * ç·¨é›†æ™‚ã«å‘¼ã°ã‚Œã‚‹çµ±åˆé–¢æ•°
 */
function onEditTrigger(e) {
  if (!e) return;

  const range = e.range;
  const sheet = range.getSheet();
  const sheetName = sheet.getName();
  const row = range.getRow();
  const col = range.getColumn();
  const val = range.getValue();
  const a1 = range.getA1Notation();

  // ãƒã‚§ãƒƒã‚¯ãƒœãƒƒã‚¯ã‚¹ã®åˆ¤å®šã‚’ç·©ã‚ã‚‹ (TRUE, true, 1 ãªã©ã«å¯¾å¿œ)
  const isChecked = (val === true || val === 'TRUE' || val === 1);

  // --- ã‚¿ã‚¹ã‚¯ä¸€è¦§(ãƒ€ãƒƒã‚·ãƒ¥ãƒœãƒ¼ãƒ‰)ã‚·ãƒ¼ãƒˆã§ã®å‡¦ç† ---
  if (sheetName === RECENT_TASK_SHEET_NAME) {
    // å®Œäº†ãƒã‚§ãƒƒã‚¯ãƒœãƒƒã‚¯ã‚¹ (Aåˆ—)
    if (col === 1 && isChecked && row >= 3) {
      completeTaskFromDashboard(sheet, row); // é«˜é€Ÿå®Œäº†å‡¦ç†
      return;
    }

    if (a1 === DASHBOARD_INTEGRATED_CHECKBOX_CELL && isChecked) {
      SpreadsheetApp.getActiveSpreadsheet().toast('åŒæ–¹å‘åŒæœŸã‚’é–‹å§‹ã—ã¾ã™...', 'å‡¦ç†ä¸­');
      try {
        ensureSheetColumns(sheet, 19);  // åˆ—æ•°å¢—åŠ ã«å¯¾å¿œ
        reflectDashboardChanges(); // å¤‰æ›´åæ˜ 
        processUnscheduledTasks(); // æœªè¨­å®šã‚¿ã‚¹ã‚¯ç™»éŒ²
        syncFromCalendarToSheets(); // ã‚«ãƒ¬ãƒ³ãƒ€ãƒ¼åæ˜ 
        updateDashboard(); // å†é›†è¨ˆ
      }
      catch (err) { console.error(err); SpreadsheetApp.getActiveSpreadsheet().toast(`ã‚¨ãƒ©ãƒ¼: ${err.message}`, 'ã‚¨ãƒ©ãƒ¼'); }
      finally { range.setValue(false); }
      return;
    }
    if (a1 === CALENDAR_IMPORT_CHECKBOX_CELL && isChecked) {
      SpreadsheetApp.getActiveSpreadsheet().toast('ã‚«ãƒ¬ãƒ³ãƒ€ãƒ¼ã®æ—¥æ™‚å¤‰æ›´ã‚’åæ˜ ä¸­...', 'å‡¦ç†ä¸­');
      try { syncFromCalendarToSheets(); }
      catch (err) { console.error(err); SpreadsheetApp.getActiveSpreadsheet().toast(`ã‚¨ãƒ©ãƒ¼: ${err.message}`, 'ã‚¨ãƒ©ãƒ¼'); }
      finally { range.setValue(false); }
      return;
    }
  }

  // --- å€‹åˆ¥ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆã‚·ãƒ¼ãƒˆã§ã®å‡¦ç† ---
  if (!EXCLUDED_SHEETS.includes(sheetName)) {
    // åŒæœŸãƒœã‚¿ãƒ³ A27
    if (a1 === 'A27' && isChecked) {
      SpreadsheetApp.getActiveSpreadsheet().toast('ã‚«ãƒ¬ãƒ³ãƒ€ãƒ¼åŒæœŸã¨ä¸¦ã³æ›¿ãˆã‚’å®Ÿè¡Œä¸­...', 'å‡¦ç†ä¸­');
      try { syncAndSortProjectSheet(sheet); } 
      catch (err) { console.error(err); SpreadsheetApp.getActiveSpreadsheet().toast(`ã‚¨ãƒ©ãƒ¼: ${err.message}`, 'ã‚¨ãƒ©ãƒ¼'); } 
      finally { range.setValue(false); }
      return;
    }
    // å®Œäº†ãƒã‚§ãƒƒã‚¯ (Aåˆ—) -> ã‚¢ãƒ¼ã‚«ã‚¤ãƒ–ç§»å‹•
    if (col === 1 && isChecked && row >= PROJECT_TASK_START_ROW) {
      archiveCompletedTask(sheet, row);
      return;
    }
    // IDè‡ªå‹•ç”Ÿæˆ (Cåˆ—)
    if (col === COL_TASK_NAME && val && row >= PROJECT_TASK_START_ROW) {
      const idCell = sheet.getRange(row, COL_TASK_ID);
      if (!idCell.getValue()) idCell.setValue(Utilities.getUuid().split('-')[0]);
    }
    return;
  }

  // --- ã‚¿ã‚¹ã‚¯å…¥åŠ›ã‚·ãƒ¼ãƒˆã§ã®å‡¦ç† ---
  if (sheetName === TASK_SHEET_NAME) {
    // å®Œäº†ãƒã‚§ãƒƒã‚¯ (Aåˆ—) -> å®Œäº†ã‚¿ã‚¹ã‚¯ã‚·ãƒ¼ãƒˆã¸ç§»å‹•
    if (col === 1 && isChecked && row >= TASK_START_ROW) {
      moveTaskToCompletedSheet(sheet, row);
      return;
    }
    // å˜ä½“åŒæœŸ
    if (a1 === SYNC_CHECKBOX_CELL && isChecked) {
      SpreadsheetApp.getActiveSpreadsheet().toast('ã‚«ãƒ¬ãƒ³ãƒ€ãƒ¼åŒæœŸã‚’é–‹å§‹ã—ã¾ã™...', 'å‡¦ç†ä¸­');
      try { syncTasksToCalendar(); } finally { range.setValue(false); }
      return;
    }
    // A3: ã€çµ±åˆæ©Ÿèƒ½ã€‘åŒæœŸãƒ»è»¢é€ãƒ»ä¸¦ã³æ›¿ãˆ
    if (a1 === 'A3' && isChecked) {
      SpreadsheetApp.getActiveSpreadsheet().toast('å…¨å‡¦ç†ã‚’ä¸€æ‹¬å®Ÿè¡Œä¸­...\n(åŒæœŸãƒ»è»¢é€ãƒ»ä¸¦ã³æ›¿ãˆ)', 'å‡¦ç†ä¸­');
      try { executeTasksAction(); } 
      catch (err) { console.error(err); SpreadsheetApp.getActiveSpreadsheet().toast(`ã‚¨ãƒ©ãƒ¼: ${err.message}`, 'ã‚¨ãƒ©ãƒ¼'); }
      finally { range.setValue(false); }
      return;
    }
    // IDç”Ÿæˆ
    if (col === COL_TASK_NAME && val && row >= TASK_START_ROW) {
      const idCell = sheet.getRange(row, COL_TASK_ID);
      if (!idCell.getValue()) idCell.setValue(Utilities.getUuid().split('-')[0]);
    }
  }

  // --- ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆä¸€è¦§ã‚·ãƒ¼ãƒˆã§ã®å‡¦ç† ---
  if (sheetName === PROJECT_SHEET_NAME && col === 1 && row >= 2 && val) {
    const projectName = String(val).trim();
    if (projectName && !SpreadsheetApp.getActiveSpreadsheet().getSheetByName(projectName)) {
      createNewSheet(projectName);
    }
  }

  // --- è¨­å®šã‚·ãƒ¼ãƒˆã§ã®å‡¦ç† (ã‚«ãƒ¬ãƒ³ãƒ€ãƒ¼å–è¾¼) ---
  if (sheetName === SETTING_SHEET_NAME) {
    // Aåˆ—ãƒã‚§ãƒƒã‚¯ -> ã‚«ãƒ¬ãƒ³ãƒ€ãƒ¼å–è¾¼å®Ÿè¡Œ (è¡Œã”ã¨ã«åˆ¤å®š)
    if (col === 1 && isChecked && row >= 2) {
      SpreadsheetApp.getActiveSpreadsheet().toast('ã‚«ãƒ¬ãƒ³ãƒ€ãƒ¼å–è¾¼ã‚’é–‹å§‹ã—ã¾ã™...', 'å‡¦ç†ä¸­');
      try { importCalendarToInbox(sheet, row); }
      catch (err) { console.error(err); SpreadsheetApp.getActiveSpreadsheet().toast(`ã‚¨ãƒ©ãƒ¼: ${err.message}`, 'ã‚¨ãƒ©ãƒ¼'); }
      finally { range.setValue(false); }
      return;
    }
  }

  // --- ã‚«ãƒ¬ãƒ³ãƒ€ãƒ¼å–è¾¼ã‚·ãƒ¼ãƒˆã§ã®å‡¦ç† (æŒ¯ã‚Šåˆ†ã‘å®Ÿè¡Œ) ---
  if (sheetName === CALENDAR_INBOX_SHEET_NAME) {
     // A3: æŒ¯ã‚Šåˆ†ã‘é–‹å§‹ (ãƒ¦ãƒ¼ã‚¶ãƒ¼è¦æœ›ã«ã‚ˆã‚ŠA3ã«å¤‰æ›´)
     if (a1 === 'A3' && isChecked) {
       SpreadsheetApp.getActiveSpreadsheet().toast('ã‚¿ã‚¹ã‚¯ã®æŒ¯ã‚Šåˆ†ã‘ãƒ»è»¢é€ã‚’é–‹å§‹ã—ã¾ã™...', 'å‡¦ç†ä¸­');
       try { distributeInboxTasks(); }
       catch (err) { console.error(err); SpreadsheetApp.getActiveSpreadsheet().toast(`ã‚¨ãƒ©ãƒ¼: ${err.message}`, 'ã‚¨ãƒ©ãƒ¼'); }
       finally { range.setValue(false); }
       return;
     }
  }
}

/**
 * æ‰‹å‹•å®Ÿè¡Œç”¨ãƒ©ãƒƒãƒ‘ãƒ¼é–¢æ•°
 */
function updateDashboardWithCalendarSync() {
  const ss = SpreadsheetApp.getActiveSpreadsheet();
  const sheet = ss.getSheetByName(RECENT_TASK_SHEET_NAME);
  if (!sheet) return;
  
  sheet.getRange(DASHBOARD_INTEGRATED_CHECKBOX_CELL).setValue(true);
  ss.toast('å…¨ã‚·ãƒ¼ãƒˆã®ã‚«ãƒ¬ãƒ³ãƒ€ãƒ¼åŒæœŸãƒ»é›†è¨ˆã‚’é–‹å§‹ã—ã¾ã™...', 'å‡¦ç†ä¸­');
  try {
    ensureSheetColumns(sheet, 18);
    reflectDashboardChanges();
    processUnscheduledTasks();
    syncFromCalendarToSheets();
    updateDashboard();
  }
  catch (err) { console.error(err); ss.toast(`ã‚¨ãƒ©ãƒ¼: ${err.message}`, 'ã‚¨ãƒ©ãƒ¼'); }
  finally { sheet.getRange(DASHBOARD_INTEGRATED_CHECKBOX_CELL).setValue(false); }
}

/**
 * ãƒ˜ãƒ«ãƒ‘ãƒ¼é–¢æ•°: æŒ‡å®šã—ãŸåˆ—æ•°ã«ãªã‚‹ã‚ˆã†ã«ã‚·ãƒ¼ãƒˆã‚’æ‹¡å¼µã™ã‚‹
 */
function ensureSheetColumns(sheet, requiredCols) {
  const currentCols = sheet.getMaxColumns();
  if (currentCols < requiredCols) {
    sheet.insertColumnsAfter(currentCols, requiredCols - currentCols);
  }
}

/**
 * ã€æ–°è¦ã€‘å³å´(æœªå®š)ãƒªã‚¹ãƒˆã§æ—¥æ™‚ãŒå…¥åŠ›ã•ã‚ŒãŸã‚¿ã‚¹ã‚¯ã‚’ã‚«ãƒ¬ãƒ³ãƒ€ãƒ¼ç™»éŒ²ã—ã€å…ƒã‚·ãƒ¼ãƒˆã¸åæ˜ 
 */
function processUnscheduledTasks() {
  const ss = SpreadsheetApp.getActiveSpreadsheet();
  const dashboardSheet = ss.getSheetByName(RECENT_TASK_SHEET_NAME);
  if (!dashboardSheet) return;

  const lastRow = dashboardSheet.getLastRow();
  if (lastRow < 3) return;

  ensureSheetColumns(dashboardSheet, 18);

  // Fetch K(11) ~ T(20) -> 10 columns
  const range = dashboardSheet.getRange(3, 11, lastRow - 2, 10);
  const values = range.getValues();
  
  const settingsSheet = ss.getSheetByName(SETTING_SHEET_NAME);
  const calendarMap = getCalendarMap(settingsSheet);
  
  let registeredCount = 0;

  values.forEach(row => {
    // Indices relative to K (0):
    // 0: Check(K)
    // 1: Proj(L)
    // 2: Task(M)
    // 3: Start(N)
    // 4: Dur(O)
    // 5: Prio(P)
    // 6: Cal(Q)
    // 7: TID(R)
    // 8: Origin(S)
    // 9: EID(T)

    const taskName = row[2];
    const startTime = row[3];
    const duration = row[4];
    const priority = row[5];
    const calType = row[6]; 
    const taskId = row[7];  
    const sheetName = row[8]; 
    const currentEventId = row[9]; 

    if (!currentEventId && taskName && taskId && sheetName && calType && startTime instanceof Date && !isNaN(startTime)) {
      
      const targetSheet = ss.getSheetByName(sheetName);
      if (!targetSheet) return;

      const startRow = (sheetName === TASK_SHEET_NAME) ? TASK_START_ROW : PROJECT_TASK_START_ROW;
      const targetLastRow = targetSheet.getLastRow();
      if (targetLastRow < startRow) return;

      const idRange = targetSheet.getRange(startRow, COL_TASK_ID, targetLastRow - startRow + 1, 1);
      const idValues = idRange.getValues();
      const targetIndex = idValues.findIndex(r => String(r[0]) === String(taskId));

      if (targetIndex !== -1) {
        const rowNum = startRow + targetIndex;
        
        if (calendarMap[calType]) {
          try {
            const cal = CalendarApp.getCalendarById(calendarMap[calType]);
            if (cal) {
              const start = new Date(startTime);
              const end = new Date(start);
              end.setMinutes(end.getMinutes() + (Number(duration) || 30));
              
              const event = cal.createEvent(taskName, start, end, {
                description: `ã‚¿ã‚¹ã‚¯ID: ${taskId}\nã‚·ãƒ¼ãƒˆé€£æº`
              });
              event.addPopupReminder(0);
              
              targetSheet.getRange(rowNum, COL_START_TIME).setValue(start);
              targetSheet.getRange(rowNum, COL_DURATION).setValue(Number(duration) || 30);
              if (priority) targetSheet.getRange(rowNum, COL_PRIORITY).setValue(priority);
              targetSheet.getRange(rowNum, COL_CAL_TYPE).setValue(calType);
              targetSheet.getRange(rowNum, COL_EVENT_ID).setValue(event.getId());
              
              registeredCount++;
            }
          } catch (e) {
            console.warn(`Calendar reg failed: ${taskName}`, e);
          }
        }
      }
    }
  });

  if (registeredCount > 0) {
    ss.toast(`${registeredCount}ä»¶ã‚’ã‚«ãƒ¬ãƒ³ãƒ€ãƒ¼ã«ç™»éŒ²ã—ã¾ã—ãŸ`, 'å®Œäº†');
  }
}

/**
 * å·¦å´(ç¢ºå®š)ãƒªã‚¹ãƒˆã®å¤‰æ›´ã‚’å…ƒã‚·ãƒ¼ãƒˆã¨ã‚«ãƒ¬ãƒ³ãƒ€ãƒ¼ã«åæ˜ 
 */
function reflectDashboardChanges() {
  const ss = SpreadsheetApp.getActiveSpreadsheet();
  const dashboardSheet = ss.getSheetByName(RECENT_TASK_SHEET_NAME);
  if (!dashboardSheet) return;

  const lastRow = dashboardSheet.getLastRow();
  if (lastRow < 3) return;

  const range = dashboardSheet.getRange(3, 1, lastRow - 2, 9); // A-I (9åˆ—)ã‚’å–å¾—
  const values = range.getValues();
  const settingsSheet = ss.getSheetByName(SETTING_SHEET_NAME);
  const calendarMap = getCalendarMap(settingsSheet); 

  const changesBySheet = {};

  values.forEach((row, i) => {
    // å¿…é ˆ: TaskID (Index 6 / Gåˆ—) ã¨ SheetName (Index 7 / Håˆ—)
    if (!row[6] || !row[7]) return; 

    const sheetName = row[7];
    if (!changesBySheet[sheetName]) changesBySheet[sheetName] = [];
    
    changesBySheet[sheetName].push({
      dashboardRowIndex: i, 
      taskName: row[2],     // C: TaskName
      startTime: row[3],    // D: StartTime
      duration: row[4],     // E: Duration
      priority: row[5],     // F: Priority
      taskId: row[6],       // G: TaskID
      eventId: row[8]       // I: EventID
    });
  });

  let updateCount = 0;

  for (const [sheetName, items] of Object.entries(changesBySheet)) {
    const targetSheet = ss.getSheetByName(sheetName);
    if (!targetSheet) continue;

    const targetLastRow = targetSheet.getLastRow();
    const startRow = (sheetName === TASK_SHEET_NAME) ? TASK_START_ROW : PROJECT_TASK_START_ROW;
    
    if (targetLastRow < startRow) continue;

    const targetRange = targetSheet.getRange(startRow, 1, targetLastRow - startRow + 1, COL_TASK_ID);
    const targetValues = targetRange.getValues();
    let sheetModified = false;

    items.forEach(item => {
      const targetIndex = targetValues.findIndex(r => String(r[COL_TASK_ID - 1]) === String(item.taskId));

      if (targetIndex !== -1) {
        const targetRowData = targetValues[targetIndex];
        let isChanged = false;
        
        const targetStart = targetRowData[COL_START_TIME - 1];
        let newStart = item.startTime;
        
        if (newStart && !(newStart instanceof Date)) newStart = new Date(newStart);

        if (newStart instanceof Date && !isNaN(newStart)) {
           if (!(targetStart instanceof Date) || Math.abs(targetStart.getTime() - newStart.getTime()) > 1000) {
             isChanged = true;
             targetRowData[COL_START_TIME - 1] = newStart;
           }
        }

        if (Number(targetRowData[COL_DURATION - 1]) != Number(item.duration)) {
          isChanged = true;
          targetRowData[COL_DURATION - 1] = item.duration;
        }

        if (targetRowData[COL_PRIORITY - 1] != item.priority) {
          isChanged = true;
          targetRowData[COL_PRIORITY - 1] = item.priority;
        }

        if (isChanged) {
          sheetModified = true;
          updateCount++;

          if (item.eventId && newStart instanceof Date) {
            const calType = targetRowData[COL_CAL_TYPE - 1];
            const calId = calendarMap[calType];
            
            if (calId) {
              try {
                const cal = CalendarApp.getCalendarById(calId);
                const event = cal.getEventById(item.eventId);
                if (event) {
                  const end = new Date(newStart);
                  end.setMinutes(end.getMinutes() + (Number(item.duration) || 30));
                  event.setTime(newStart, end);
                }
              } catch (e) {
                console.warn(`Calendar update failed: ${item.eventId}`, e);
              }
            }
          }
        }
      }
    });

    if (sheetModified) {
      targetRange.setValues(targetValues);
    }
  }

  if (updateCount > 0) {
    ss.toast(`${updateCount}ä»¶ã®å¤‰æ›´ã‚’åæ˜ ã—ã¾ã—ãŸ`, 'å®Œäº†');
  }
}

/**
 * ã€æ–°æ©Ÿèƒ½ã€‘ã‚«ãƒ¬ãƒ³ãƒ€ãƒ¼ã‹ã‚‰æ—¥æ™‚æƒ…å ±ã‚’å…¨ã‚·ãƒ¼ãƒˆã¸åæ˜ 
 */
function syncFromCalendarToSheets() {
  const ss = SpreadsheetApp.getActiveSpreadsheet();
  const settingsSheet = ss.getSheetByName(SETTING_SHEET_NAME);
  
  const calendarMap = getCalendarMap(settingsSheet);
  const calendarIds = Object.values(calendarMap);
  if (calendarIds.length === 0) return;

  const startTime = new Date();
  startTime.setDate(startTime.getDate() - 7); 
  startTime.setHours(0, 0, 0, 0);
  
  const endTime = new Date();
  endTime.setMonth(endTime.getMonth() + 2); 

  const eventMap = new Map();

  calendarIds.forEach(calId => {
    try {
      const cal = CalendarApp.getCalendarById(calId);
      if (cal) {
        const events = cal.getEvents(startTime, endTime);
        events.forEach(evt => {
          const evtId = evt.getId();
          const start = evt.getStartTime();
          const end = evt.getEndTime();
          const duration = Math.round((end.getTime() - start.getTime()) / (1000 * 60));
          eventMap.set(evtId, { start: start, duration: duration });
        });
      }
    } catch (e) {
      console.warn(`Calendar access error: ${calId}`, e);
    }
  });

  if (eventMap.size === 0) return;

  let updatedCount = 0;
  
  const targetSheets = [];
  const taskSheet = ss.getSheetByName(TASK_SHEET_NAME);
  if (taskSheet) targetSheets.push({ sheet: taskSheet, startRow: TASK_START_ROW });

  const allSheets = ss.getSheets();
  allSheets.forEach(sheet => {
    const sName = sheet.getName();
    if (!EXCLUDED_SHEETS.includes(sName)) {
      targetSheets.push({ sheet: sheet, startRow: PROJECT_TASK_START_ROW });
    }
  });

  targetSheets.forEach(target => {
    const sheet = target.sheet;
    const startRow = target.startRow;
    const lastRow = sheet.getLastRow();
    
    if (lastRow >= startRow) {
      const numRows = lastRow - startRow + 1;
      const range = sheet.getRange(startRow, 1, numRows, TASK_AREA_LAST_COL);
      const values = range.getValues();
      let sheetUpdated = false;

      for (let i = 0; i < values.length; i++) {
        const rowData = values[i];
        const eventId = rowData[COL_EVENT_ID - 1]; 

        if (eventId && eventMap.has(eventId)) {
          const calData = eventMap.get(eventId);
          const currentStart = rowData[COL_START_TIME - 1];
          const currentDuration = rowData[COL_DURATION - 1];

          let isDiff = false;
          
          if (currentStart instanceof Date) {
            if (Math.abs(currentStart.getTime() - calData.start.getTime()) > 1000) isDiff = true;
          } else {
            isDiff = true; 
          }

          if (Number(currentDuration) !== calData.duration) isDiff = true;

          if (isDiff) {
            values[i][COL_START_TIME - 1] = calData.start;
            values[i][COL_DURATION - 1] = calData.duration;
            updatedCount++;
            sheetUpdated = true;
          }
        }
      }

      if (sheetUpdated) {
        range.setValues(values);
      }
    }
  });

  if (updatedCount > 0) {
    ss.toast(`${updatedCount}ä»¶ã®ã‚¿ã‚¹ã‚¯æ—¥æ™‚ã‚’ã‚«ãƒ¬ãƒ³ãƒ€ãƒ¼ã‹ã‚‰æ›´æ–°ã—ã¾ã—ãŸ`, 'å®Œäº†');
  }
}

/**
 * ãƒ€ãƒƒã‚·ãƒ¥ãƒœãƒ¼ãƒ‰æ›´æ–°æ©Ÿèƒ½
 */
/**
 * ãƒ€ãƒƒã‚·ãƒ¥ãƒœãƒ¼ãƒ‰æ›´æ–°æ©Ÿèƒ½ (ãƒ¬ã‚¤ã‚¢ã‚¦ãƒˆå¤‰æ›´: Aåˆ—ã«ãƒã‚§ãƒƒã‚¯ãƒœãƒƒã‚¯ã‚¹è¿½åŠ )
 */
function updateDashboard() {
  const ss = SpreadsheetApp.getActiveSpreadsheet();
  const dashboardSheet = ss.getSheetByName(RECENT_TASK_SHEET_NAME);

  if (!dashboardSheet) {
    ss.toast(`ã‚¨ãƒ©ãƒ¼: ã‚·ãƒ¼ãƒˆ "${RECENT_TASK_SHEET_NAME}" ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“ã€‚`, 'ã‚¨ãƒ©ãƒ¼');
    return;
  }

  ensureSheetColumns(dashboardSheet, 19); // 1åˆ—å¢—ãˆãŸã®ã§18->19

  const settingsSheet = ss.getSheetByName(SETTING_SHEET_NAME);
  const calendarMap = getCalendarMap(settingsSheet);
  const calendarNames = Object.keys(calendarMap);

  // è¨­å®šã‚·ãƒ¼ãƒˆã‹ã‚‰æ‰€è¦æ™‚é–“ãƒªã‚¹ãƒˆã‚’å–å¾—
  let durationList = ['15', '30', '45', '60', '90', '120', '180'];
  const settingsLastRow = settingsSheet.getLastRow();
  if (settingsLastRow >= 2) {
    const durationVals = settingsSheet.getRange(2, SETTINGS_DURATION_COL, settingsLastRow - 1, 1).getValues();
    const customDurations = durationVals.flat().filter(v => v !== '').map(String);
    if (customDurations.length > 0) {
      durationList = customDurations;
    }
  }

  let targetSheets = [];
  const taskSheet = ss.getSheetByName(TASK_SHEET_NAME);
  if (taskSheet) targetSheets.push({ sheet: taskSheet, startRow: TASK_START_ROW, name: TASK_SHEET_NAME }); 

  const allSheets = ss.getSheets();
  allSheets.forEach(sheet => {
    const sName = sheet.getName();
    if (!EXCLUDED_SHEETS.includes(sName)) {
      targetSheets.push({ sheet: sheet, startRow: PROJECT_TASK_START_ROW, name: sName });
    }
  });

  const today = new Date();
  today.setHours(0, 0, 0, 0);
  
  const tomorrow = new Date(today);
  tomorrow.setDate(today.getDate() + 1);
  
  const dayAfterTomorrow = new Date(today);
  dayAfterTomorrow.setDate(today.getDate() + 2);
  
  const threeDaysLater = new Date(today);
  threeDaysLater.setDate(today.getDate() + 3);

  let tasks = [];

  targetSheets.forEach(target => {
    const lastRow = target.sheet.getLastRow();
    if (lastRow >= target.startRow) {
      const numRows = lastRow - target.startRow + 1;
      const data = target.sheet.getRange(target.startRow, 1, numRows, TASK_AREA_LAST_COL).getValues();

      data.forEach(row => {
        const isCompleted = (row[0] === true);
        const taskName = row[COL_TASK_NAME - 1];

        if (!isCompleted && taskName) {
          let startTime = row[COL_START_TIME - 1];
          let hasDate = false;

          if (startTime) {
             if (!(startTime instanceof Date)) {
                const d = new Date(startTime);
                if (!isNaN(d.getTime())) {
                    startTime = d;
                    hasDate = true;
                }
             } else if (!isNaN(startTime.getTime())) {
                 hasDate = true;
             }
          }

          if (hasDate) {
            const d = new Date(startTime);
            d.setHours(0, 0, 0, 0);
            const checkDateVal = d.getTime();

            if (checkDateVal < threeDaysLater.getTime()) {
              tasks.push({
                projectName: (target.name === TASK_SHEET_NAME && row[COL_PROJECT_NAME - 1]) ? row[COL_PROJECT_NAME - 1] : target.name,
                taskName: taskName,
                startTime: startTime,
                checkDate: checkDateVal,
                duration: row[COL_DURATION - 1],
                priority: row[COL_PRIORITY - 1],
                taskId: row[COL_TASK_ID - 1],     
                originSheet: target.name,         
                eventId: row[COL_EVENT_ID - 1],
                calType: row[COL_CAL_TYPE - 1]
              });
            }
          } else {
            tasks.push({
                type: 'unscheduled',
                projectName: (target.name === TASK_SHEET_NAME && row[COL_PROJECT_NAME - 1]) ? row[COL_PROJECT_NAME - 1] : target.name,
                taskName: taskName,
                startTime: '',
                duration: row[COL_DURATION - 1],
                priority: row[COL_PRIORITY - 1],
                calType: row[COL_CAL_TYPE - 1],
                taskId: row[COL_TASK_ID - 1],
                originSheet: target.name,
                eventId: row[COL_EVENT_ID - 1]
            });
          }
        }
      });
    }
  });

  const expiredTasks = [];
  const todayTasks = [];
  const tomorrowTasks = [];
  const dayAfterTasks = [];
  const unscheduledTasks = [];

  tasks.forEach(t => {
    if (t.type === 'unscheduled') {
        unscheduledTasks.push(t);
    } else {
        if (t.checkDate < today.getTime()) expiredTasks.push(t);
        else if (t.checkDate < tomorrow.getTime()) todayTasks.push(t);
        else if (t.checkDate < dayAfterTomorrow.getTime()) tomorrowTasks.push(t);
        else dayAfterTasks.push(t);
    }
  });

  const priorityMap = { 'ç·Šæ€¥': 4, 'é«˜ã„': 3, 'ä¸­': 2, 'ä½ã„': 1 };
  const sortFunc = (a, b) => {
    if (a.checkDate !== b.checkDate) return a.checkDate - b.checkDate;
    if (a.startTime.getTime() !== b.startTime.getTime()) {
        return a.startTime.getTime() - b.startTime.getTime();
    }
    const pA = priorityMap[a.priority] || 0;
    const pB = priorityMap[b.priority] || 0;
    if (pA !== pB) return pB - pA;
    return (Number(a.duration)||0) - (Number(b.duration)||0);
  };

  const unscheduledSortFunc = (a, b) => {
    const pA = priorityMap[a.priority] || 0;
    const pB = priorityMap[b.priority] || 0;
    if (pA !== pB) return pB - pA;
    return (Number(a.duration)||0) - (Number(b.duration)||0);
  };

  expiredTasks.sort(sortFunc);
  todayTasks.sort(sortFunc);
  tomorrowTasks.sort(sortFunc);
  dayAfterTasks.sort(sortFunc);
  unscheduledTasks.sort(unscheduledSortFunc);

  let leftRows = [];
  let pinkRows = [], greenRows = [], boldRows = [];
  const formatDate = (d) => Utilities.formatDate(d, Session.getScriptTimeZone(), 'MM/dd(E)');
  const emptyRow9 = ['', '', '', '', '', '', '', '', '']; // 9è¦ç´ 

  if (expiredTasks.length > 0) {
    leftRows.push([false, 'âš  æœŸé™åˆ‡ã‚Œãƒ»æœªå®Œäº†', '', '', '', '', '', '', '']); // falseã§ãƒã‚§ãƒƒã‚¯ãƒœãƒƒã‚¯ã‚¹ç¶­æŒ
    boldRows.push(leftRows.length - 1);
    expiredTasks.forEach(t => {
      // A:Check, B:Proj, C:Task, D:Start, E:Dur, F:Prio, G:TID(Hide), H:Origin(Hide), I:EID(Hide)
      leftRows.push([false, t.projectName, t.taskName, t.startTime, t.duration, t.priority, t.taskId, t.originSheet, t.eventId]);
      greenRows.push(leftRows.length - 1);
    });
    leftRows.push(emptyRow9);
  }
  leftRows.push([false, `â–  æœ¬æ—¥ (${formatDate(today)})`, '', '', '', '', '', '', '']);
  boldRows.push(leftRows.length - 1);
  if (todayTasks.length === 0) {
    leftRows.push([false, '(äºˆå®šãªã—)', '', '', '', '', '', '', '']);
  } else {
    todayTasks.forEach(t => {
      leftRows.push([false, t.projectName, t.taskName, t.startTime, t.duration, t.priority, t.taskId, t.originSheet, t.eventId]);
      pinkRows.push(leftRows.length - 1); 
    });
  }
  leftRows.push(emptyRow9);
  leftRows.push([false, `â–  æ˜æ—¥ (${formatDate(tomorrow)})`, '', '', '', '', '', '', '']);
  boldRows.push(leftRows.length - 1);
  if (tomorrowTasks.length === 0) leftRows.push([false, '(äºˆå®šãªã—)', '', '', '', '', '', '', '']);
  else tomorrowTasks.forEach(t => leftRows.push([false, t.projectName, t.taskName, t.startTime, t.duration, t.priority, t.taskId, t.originSheet, t.eventId]));
  leftRows.push(emptyRow9);
  leftRows.push([false, `â–  æ˜å¾Œæ—¥ (${formatDate(dayAfterTomorrow)})`, '', '', '', '', '', '', '']);
  boldRows.push(leftRows.length - 1);
  if (dayAfterTasks.length === 0) leftRows.push([false, '(äºˆå®šãªã—)', '', '', '', '', '', '', '']);
  else dayAfterTasks.forEach(t => leftRows.push([false, t.projectName, t.taskName, t.startTime, t.duration, t.priority, t.taskId, t.originSheet, t.eventId]));

  // å³å´: [Check, Proj, Task, Start, Dur, Prio, CalType, TID, Origin, EID] -> 10 cols?
  // ãƒ€ãƒƒã‚·ãƒ¥ãƒœãƒ¼ãƒ‰ãƒ‡ã‚¶ã‚¤ãƒ³: 
  // å·¦: A-I (9)
  // ã‚¹ãƒšãƒ¼ã‚µãƒ¼: J (10)
  // å³: K-T (10) 
  // å³ã®æ§‹æˆ: [Check, Proj, Task, Start(Empty), Dur, Prio, Cal, TID, Origin, EID]
  let rightRows = [];
  rightRows.push([false, 'ã€æœªè¨­å®šã‚¿ã‚¹ã‚¯ã€‘', '', '', '', '', '', '', '', '']);
  unscheduledTasks.forEach(t => {
    rightRows.push([false, t.projectName, t.taskName, t.startTime, t.duration, t.priority, t.calType, t.taskId, t.originSheet, t.eventId]);
  });

  const maxLines = Math.max(leftRows.length, rightRows.length);
  const startRow = 3;
  
  // ãƒã‚§ãƒƒã‚¯ãƒœãƒƒã‚¯ã‚¹å¸¸è¨­åŒ–ï¼ˆé«˜é€ŸåŒ–ï¼‰
  // A3ã«æ¤œè¨¼ãƒ«ãƒ¼ãƒ«ãŒãªã‘ã‚Œã°ä½œæˆ (åˆå›ã®ã¿)
  const a3Val = dashboardSheet.getRange('A3').getDataValidation();
  if (!a3Val) {
      dashboardSheet.getRange(startRow, 1, 1000, 1).insertCheckboxes();
      dashboardSheet.getRange(startRow, 11, 1000, 1).insertCheckboxes();
      // ã‚‚ã—æ—¢ã«ãƒ‡ãƒ¼ã‚¿ãŒã‚ã‚Œã°æ¶ˆã•ãªã„ã‚ˆã†ã«æ³¨æ„ã ãŒã€ã“ã“ã¯åˆæœŸåŒ–ã«è¿‘ã„ã®ã§OK
  }

  const currentMax = dashboardSheet.getLastRow();
  const clearHeight = Math.max(currentMax - startRow + 1, maxLines); // æ¶ˆã™ç¯„å›²ç¢ºä¿
  
  if (clearHeight > 0) {
    // A, Kåˆ—ã¯ãƒã‚§ãƒƒã‚¯ãƒœãƒƒã‚¯ã‚¹ç¶­æŒã®ãŸã‚Contentã®ã¿ã‚¯ãƒªã‚¢
    dashboardSheet.getRange(startRow, 1, clearHeight, 1).clearContent(); // A
    dashboardSheet.getRange(startRow, 11, clearHeight, 1).clearContent(); // K
    
    // ä»–ã®åˆ—ã¯å…¨ã‚¯ãƒªã‚¢ (Validationå«ã‚€)
    // B-J (2-10) => 9åˆ—
    dashboardSheet.getRange(startRow, 2, clearHeight, 9).clearContent().clearDataValidations().clearFormat();
    // L-T (12-20) => 9åˆ—
    dashboardSheet.getRange(startRow, 12, clearHeight, 9).clearContent().clearDataValidations().clearFormat();
  }

  const finalValues = [];
  for (let i = 0; i < maxLines; i++) {
    const left = leftRows[i] || emptyRow9;
    const right = rightRows[i] || [false, '', '', '', '', '', '', '', '', '']; // Right filler
    finalValues.push([...left, '', ...right]); // Left(9) + Spacer(1) + Right(10) = 20
  }

  if (finalValues.length > 0) {
    // ç¯„å›²æ›¸ãè¾¼ã¿: A3 ~ (maxLinesè¡Œ) x 20åˆ—
    const range = dashboardSheet.getRange(startRow, 1, finalValues.length, 20);
    range.setValues(finalValues);

    // ãƒ˜ãƒƒãƒ€ãƒ¼æ›¸ãæˆ»ã—(ã‚ºãƒ¬å¯¾å¿œ)
    dashboardSheet.getRange('B2').setValue('ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆå');
    dashboardSheet.getRange('C2').setValue('ã‚¿ã‚¹ã‚¯å');
    dashboardSheet.getRange('D2').setValue('é–‹å§‹æ—¥æ™‚');
    dashboardSheet.getRange('E2').setValue('æ‰€è¦æ™‚é–“');
    dashboardSheet.getRange('F2').setValue('å„ªå…ˆåº¦');

    dashboardSheet.getRange('L2').setValue('ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆå');
    dashboardSheet.getRange('M2').setValue('ã‚¿ã‚¹ã‚¯å');
    dashboardSheet.getRange('N2').setValue('æ‰€è¦æ™‚é–“'); // Startã¯ã‚¹ã‚­ãƒƒãƒ—
    dashboardSheet.getRange('O2').setValue('æ‰€è¦æ™‚é–“');
    dashboardSheet.getRange('P2').setValue('å„ªå…ˆåº¦');
    dashboardSheet.getRange('Q2').setValue('ã‚«ãƒ¬ãƒ³ãƒ€ãƒ¼');

    const priorityRule = SpreadsheetApp.newDataValidation().requireValueInList(['ç·Šæ€¥', 'é«˜ã„', 'ä¸­', 'ä½ã„'], true).setAllowInvalid(false).build();
    const durationRule = SpreadsheetApp.newDataValidation().requireValueInList(durationList, true).setAllowInvalid(false).build();
    const dateRule = SpreadsheetApp.newDataValidation().requireDate().setAllowInvalid(true).build();
    
    let calendarRule = null;
    if (calendarNames.length > 0) {
        calendarRule = SpreadsheetApp.newDataValidation().requireValueInList(calendarNames, true).setAllowInvalid(false).build();
    }

    const rangeE = dashboardSheet.getRange(startRow, 5, maxLines, 1); // E: Dur (old 4+1)
    const rangeF = dashboardSheet.getRange(startRow, 6, maxLines, 1); // F: Prio (old 5+1)
    
    // å³å´
    // K: Check, L: Proj, M: Task, N: Start, O: Dur, P: Prio, Q: Cal
    const rangeO = dashboardSheet.getRange(startRow, 15, maxLines, 1); // O: Dur
    const rangeP = dashboardSheet.getRange(startRow, 16, maxLines, 1); // P: Prio
    const rangeQ = dashboardSheet.getRange(startRow, 17, maxLines, 1); // Q: Cal

    const rangeD = dashboardSheet.getRange(startRow, 4, maxLines, 1); // D: Start
    const rangeN = dashboardSheet.getRange(startRow, 14, maxLines, 1); // N: Start(Right)

    try {
      rangeF.setDataValidation(priorityRule);
      rangeP.setDataValidation(priorityRule);
      rangeE.setDataValidation(durationRule);
      rangeO.setDataValidation(durationRule);
      rangeD.setDataValidation(dateRule);
      rangeN.setDataValidation(dateRule);
      if (calendarRule) rangeQ.setDataValidation(calendarRule);
    } catch(e) {}

    // ãƒã‚§ãƒƒã‚¯ãƒœãƒƒã‚¯ã‚¹ã®å†ç”Ÿæˆã¨å‰Šé™¤ãƒ«ãƒ¼ãƒ—(removeCheckboxes)ã‚’å»ƒæ­¢ã—é«˜é€ŸåŒ–
    // (ãƒ¦ãƒ¼ã‚¶ãƒ¼åˆæ„ã«ã‚ˆã‚Šãƒ˜ãƒƒãƒ€ãƒ¼è¡Œã«ã‚‚ãƒã‚§ãƒƒã‚¯ãƒœãƒƒã‚¯ã‚¹ãŒè¡¨ç¤ºã•ã‚Œã‚‹ä»•æ§˜)

    dashboardSheet.clearConditionalFormatRules();

    if (greenRows.length) dashboardSheet.getRangeList(greenRows.map(i => `A${startRow+i}:F${startRow+i}`)).setBackground('#F0F8F0');
    if (pinkRows.length) dashboardSheet.getRangeList(pinkRows.map(i => `A${startRow+i}:F${startRow+i}`)).setBackground('#FFE0E0');
    if (boldRows.length) {
      const ranges = dashboardSheet.getRangeList(boldRows.map(i => `A${startRow+i}:F${startRow+i}`));
      ranges.setFontWeight('bold').setBackground('#EEEEEE');
    }
    // éè¡¨ç¤ºåˆ—ã‚¨ãƒªã‚¢
    dashboardSheet.getRange(`G${startRow}:I${startRow}`).setFontWeight('bold'); // å·¦éš ã—
    dashboardSheet.getRange(`R${startRow}:T${startRow}`).setFontWeight('bold'); // å³éš ã—

    dashboardSheet.getRange(startRow, 4, maxLines, 1).setNumberFormat('MM/dd HH:mm');
    dashboardSheet.getRange(startRow, 14, maxLines, 1).setNumberFormat('MM/dd HH:mm');

    // åˆ—éš ã— (G=7, H=8, I=9) -> 3åˆ—
    dashboardSheet.hideColumns(7, 3); 
    // å³å´éš ã— (R=18, S=19, T=20) -> 3åˆ— (TID, Origin, EID)
    dashboardSheet.hideColumns(18, 3);
  }

  ss.toast('ã‚¿ã‚¹ã‚¯ä¸€è¦§ã‚’æ›´æ–°ã—ã¾ã—ãŸ', 'å®Œäº†');
}

/**
 * ãƒ€ãƒƒã‚·ãƒ¥ãƒœãƒ¼ãƒ‰ã‹ã‚‰ã®é«˜é€Ÿå®Œäº†å‡¦ç†
 */
function completeTaskFromDashboard(sheet, row) {
  // å·¦å´: A(1)ãƒã‚§ãƒƒã‚¯ -> G(7)=TID, H(8)=Origin, I(9)=EID
  // å³å´: K(11)ãƒã‚§ãƒƒã‚¯ -> R(18)=TID, S(19)=Origin, T(20)=EID
  // ã©ã¡ã‚‰ã®ãƒã‚§ãƒƒã‚¯ãƒœãƒƒã‚¯ã‚¹ãŒæŠ¼ã•ã‚ŒãŸã‹åˆ¤å®šã¯é›£ã—ã„ã®ã§ã€ä¸¡æ–¹ãƒã‚§ãƒƒã‚¯ã™ã‚‹(ã‚ã‚‹ã„ã¯getActiveCellã§åˆ¤å®š)
  
  const activeCol = sheet.getActiveCell().getColumn();
  let tidIndex, originIndex;

  if (activeCol === 1) { // å·¦å´
    tidIndex = 7;
    originIndex = 8;
  } else if (activeCol === 11) { // å³å´
    tidIndex = 18;
    originIndex = 19;
  } else {
    return; // Aåˆ—ã§ã‚‚Kåˆ—ã§ã‚‚ãªã‘ã‚Œã°ä½•ã‚‚ã—ãªã„
  }

  const rowVals = sheet.getRange(row, 1, 1, 20).getValues()[0];
  const taskId = rowVals[tidIndex - 1];
  const originSheetName = rowVals[originIndex - 1];

  // Header Check: If no Task ID, it's a header or spacer. Uncheck and return.
  if (!taskId) {
    sheet.getRange(row, activeCol).setValue(false);
    return;
  }

  // ç”»é¢ä¸Šã‹ã‚‰å³åº§ã«æ¶ˆã™ (è¡Œå‰Šé™¤ã§ã¯ãªãã‚»ãƒ«å‰Šé™¤ã§ä¸Šã«è©°ã‚ã‚‹)
  try {
    if (activeCol === 1) {
      sheet.getRange(row, 1, 1, 9).deleteCells(SpreadsheetApp.Dimension.ROWS);
    } else {
      sheet.getRange(row, 11, 1, 10).deleteCells(SpreadsheetApp.Dimension.ROWS); // ã‚¹ãƒšãƒ¼ã‚µãƒ¼Jã¯å«ã‚ãªã„
    }
    SpreadsheetApp.getActiveSpreadsheet().toast('ã‚¿ã‚¹ã‚¯ã‚’å®Œäº†ã—ã¾ã—ãŸ', 'å®Œäº†');
  } catch (e) {
    console.error(e);
  }

  // è£å´ã§æœ¬å‡¦ç†
  if (taskId && originSheetName) {
    const ss = SpreadsheetApp.getActiveSpreadsheet();
    const originSheet = ss.getSheetByName(originSheetName);
    if (originSheet) {
      // IDã§æ¤œç´¢
      const startRow = (originSheetName === TASK_SHEET_NAME) ? TASK_START_ROW : PROJECT_TASK_START_ROW;
      const lastRow = originSheet.getLastRow();
      if (lastRow >= startRow) {
        const ids = originSheet.getRange(startRow, COL_TASK_ID, lastRow - startRow + 1, 1).getValues();
        const targetIndex = ids.findIndex(r => String(r[0]) === String(taskId));
        
        if (targetIndex !== -1) {
          const targetRow = startRow + targetIndex;
          if (originSheetName === TASK_SHEET_NAME) {
            moveTaskToCompletedSheet(originSheet, targetRow);
          } else {
            archiveCompletedTask(originSheet, targetRow);
          }
        }
      }
    }
  }
}

/**
 * ã‚·ãƒ¼ãƒˆä½œæˆã®å®Ÿå‡¦ç† (Templateã‚’ã‚³ãƒ”ãƒ¼)
 */
function createNewSheet(name) {
  const ss = SpreadsheetApp.getActiveSpreadsheet();
  const templateSheet = ss.getSheetByName(TEMPLATE_SHEET_NAME);
  const settingsSheet = ss.getSheetByName(SETTING_SHEET_NAME);
  
  if (!templateSheet) {
    ss.toast(`ã‚¨ãƒ©ãƒ¼: "${TEMPLATE_SHEET_NAME}" ã‚·ãƒ¼ãƒˆãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“ã€‚`, 'ã‚¨ãƒ©ãƒ¼', 10);
    return;
  }
  if (ss.getSheetByName(name)) return;

  const originalActiveSheet = ss.getActiveSheet();

  try {
    const newSheet = templateSheet.copyTo(ss);
    newSheet.setName(name);
    newSheet.setTabColor(null); // ã‚¿ãƒ–è‰²ã‚’ãƒªã‚»ãƒƒãƒˆ
    newSheet.activate();
    
    if (settingsSheet) {
      const targetIndex = settingsSheet.getIndex();
      ss.moveActiveSheet(targetIndex);
    }

    const titleCell = newSheet.getRange('A3');
    titleCell.setValue(name);
    titleCell.setFontSize(14);
    titleCell.setFontWeight('bold');

    originalActiveSheet.activate();
    ss.toast(`ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆã‚·ãƒ¼ãƒˆ "${name}" ã‚’ä½œæˆã—ã¾ã—ãŸ`, 'å®Œäº†', 5);
  } catch (err) {
    ss.toast(`ä½œæˆã‚¨ãƒ©ãƒ¼: ${err.message}`, 'ã‚¨ãƒ©ãƒ¼', 10);
  }
}

/**
 * è£œåŠ©é–¢æ•°: ã‚«ãƒ¬ãƒ³ãƒ€ãƒ¼IDãƒãƒƒãƒ—å–å¾—
 */
function getCalendarMap(sheet) {
  const lastRow = sheet.getLastRow();
  if (lastRow < 2) return {};
  const data = sheet.getRange(2, 1, lastRow - 1, 3).getValues();
  const map = {};
  data.forEach(row => {
    const name = row[SETTINGS_NAME_COL - 1];
    let id = row[SETTINGS_ID_COL - 1];
    if (id && id.includes('calendar.google.com')) {
      const match = id.match(/src=([^&]+)/);
      if (match) id = decodeURIComponent(match[1]);
      else {
        const cidMatch = id.match(/cid=([^&]+)/);
        if (cidMatch) id = decodeURIComponent(cidMatch[1]);
      }
    }
    if (name && id) map[name] = id;
  });
  return map;
}

// === ä»¥ä¸‹ã€å¾©æ´»ã—ãŸæ—¢å­˜é–¢æ•°ç¾¤ ===

function moveTaskToCompletedSheet(sourceSheet, row) {
  const ss = SpreadsheetApp.getActiveSpreadsheet();
  const targetSheet = ss.getSheetByName(COMPLETED_SHEET_NAME);
  if (!targetSheet) {
    ss.toast(`ã‚¨ãƒ©ãƒ¼: ã‚·ãƒ¼ãƒˆ "${COMPLETED_SHEET_NAME}" ãŒã‚ã‚Šã¾ã›ã‚“`, 'ã‚¨ãƒ©ãƒ¼');
    sourceSheet.getRange(row, 1).setValue(false);
    return;
  }
  try {
    const targetRow = 2;
    targetSheet.insertRowBefore(targetRow);
    const lastCol = sourceSheet.getLastColumn();
    ensureSheetColumns(targetSheet, lastCol + 1);

    const sourceRange = sourceSheet.getRange(row, 1, 1, lastCol);
    sourceRange.copyTo(targetSheet.getRange(targetRow, 1));
    targetSheet.getRange(targetRow, lastCol + 1).setValue(new Date());
    
    sourceSheet.deleteRow(row);
    ss.toast('ã‚¿ã‚¹ã‚¯ã‚’å®Œäº†ã‚·ãƒ¼ãƒˆã¸ã‚¢ãƒ¼ã‚«ã‚¤ãƒ–ã—ã¾ã—ãŸ', 'å®Œäº†');
  } catch (e) {
    ss.toast(`ç§»å‹•ã‚¨ãƒ©ãƒ¼: ${e.message}`, 'ã‚¨ãƒ©ãƒ¼');
  }
}

function archiveCompletedTask(sheet, row) {
  try {
    const sourceRange = sheet.getRange(row, 1, 1, TASK_AREA_LAST_COL);
    const archiveRangeWidth = TASK_AREA_LAST_COL; 
    const insertRange = sheet.getRange(ARCHIVE_START_ROW, ARCHIVE_START_COL, 1, archiveRangeWidth);
    insertRange.insertCells(SpreadsheetApp.Dimension.ROWS);
    
    ensureSheetColumns(sheet, 24); // Xåˆ—(24)ã¾ã§ç¢ºä¿
    sourceRange.copyTo(sheet.getRange(ARCHIVE_START_ROW, ARCHIVE_START_COL));
    sheet.getRange(ARCHIVE_START_ROW, 24).setValue(new Date()); // Xåˆ—ã«ã‚¿ã‚¤ãƒ ã‚¹ã‚¿ãƒ³ãƒ—
    
    sourceRange.deleteCells(SpreadsheetApp.Dimension.ROWS);
    SpreadsheetApp.getActiveSpreadsheet().toast('å®Œäº†ã‚¿ã‚¹ã‚¯ã‚’ã‚¢ãƒ¼ã‚«ã‚¤ãƒ–ã—ã¾ã—ãŸ', 'å®Œäº†');
  } catch (e) {
    SpreadsheetApp.getActiveSpreadsheet().toast(`ç§»å‹•ä¸­ã«ã‚¨ãƒ©ãƒ¼: ${e.message}`, 'ã‚¨ãƒ©ãƒ¼');
  }
}

function createProjectSheets() {
  const ss = SpreadsheetApp.getActiveSpreadsheet();
  const pSheet = ss.getSheetByName(PROJECT_SHEET_NAME);
  if (!pSheet) return;
  const vals = pSheet.getRange(2, 1, pSheet.getLastRow()-1, 1).getValues();
  vals.forEach(r => { 
    if(r[0] && !ss.getSheetByName(String(r[0]).trim())) {
      createNewSheet(String(r[0]).trim());
    }
  });
}

function syncTasksToCalendar() {
  const ss = SpreadsheetApp.getActiveSpreadsheet();
  const taskSheet = ss.getSheetByName(TASK_SHEET_NAME);
  const settingsSheet = ss.getSheetByName(SETTING_SHEET_NAME);
  if (!taskSheet || !settingsSheet) return;
  const calMap = getCalendarMap(settingsSheet);
  const lastRow = taskSheet.getLastRow();
  if (lastRow < TASK_START_ROW) return;

  const range = taskSheet.getRange(TASK_START_ROW, 1, lastRow - TASK_START_ROW + 1, taskSheet.getLastColumn());
  const vals = range.getValues();
  const ids = [];

  for (let i=0; i<vals.length; i++) {
    const row = vals[i];
    const [task, start, dur, type, eid, tid] = [
      row[COL_TASK_NAME-1], row[COL_START_TIME-1], row[COL_DURATION-1],
      row[COL_CAL_TYPE-1], row[COL_EVENT_ID-1], row[COL_TASK_ID-1]
    ];
    if (!eid && task && start && dur && type && tid && calMap[type]) {
      try {
        const cal = CalendarApp.getCalendarById(calMap[type]);
        if (cal) {
          const end = new Date(start);
          end.setMinutes(end.getMinutes() + Number(dur));
          const ev = cal.createEvent(task, start, end, { description: `ã‚¿ã‚¹ã‚¯ID: ${tid}\nProjectsè‡ªå‹•é€£æº` });
          ev.addPopupReminder(0);
          ids.push([ev.getId()]);
        } else { ids.push([eid]); }
      } catch(e) { ids.push([eid]); }
    } else { ids.push([eid]); }
  }
  if (ids.length) taskSheet.getRange(TASK_START_ROW, COL_EVENT_ID, ids.length, 1).setValues(ids);
  ss.toast('Tasksã‚·ãƒ¼ãƒˆåŒæœŸå®Œäº†', 'å®Œäº†');
}

function executeTasksAction() {
  const ss = SpreadsheetApp.getActiveSpreadsheet();
  const taskSheet = ss.getSheetByName(TASK_SHEET_NAME);
  const settingsSheet = ss.getSheetByName(SETTING_SHEET_NAME);
  const calendarMap = getCalendarMap(settingsSheet);

  if (!taskSheet) return;

  const lastRow = taskSheet.getLastRow();
  if (lastRow < TASK_START_ROW) {
    ss.toast('å‡¦ç†å¯¾è±¡ã®ã‚¿ã‚¹ã‚¯ãŒã‚ã‚Šã¾ã›ã‚“', 'å®Œäº†');
    return;
  }

  const MAX_CHECK_ROWS = 60;
  const processRows = Math.min(lastRow - TASK_START_ROW + 1, MAX_CHECK_ROWS);
  const range = taskSheet.getRange(TASK_START_ROW, 1, processRows, TASK_AREA_LAST_COL);
  const values = range.getValues();
  
  let syncCount = 0;
  let idUpdated = false;

  for (let i = 0; i < values.length; i++) {
    const rowData = values[i];
    if (!rowData.some(c => c !== '')) continue;

    const taskName  = rowData[COL_TASK_NAME - 1];
    const startTime = rowData[COL_START_TIME - 1];
    const duration  = rowData[COL_DURATION - 1];
    const calType   = rowData[COL_CAL_TYPE - 1];
    const eventId   = rowData[COL_EVENT_ID - 1];
    let taskId    = rowData[COL_TASK_ID - 1];

    if (!taskId && taskName) {
        taskId = Utilities.getUuid().split('-')[0];
        values[i][COL_TASK_ID - 1] = taskId;
        idUpdated = true;
    }

    if (!eventId && taskName && startTime && taskId) {
      if (calType && calendarMap[calType]) {
        try {
          const calendar = CalendarApp.getCalendarById(calendarMap[calType]);
          if (calendar) {
            const startDate = new Date(startTime);
            const endDate = new Date(startDate);
            const dur = Number(duration) || 30;
            endDate.setMinutes(endDate.getMinutes() + dur);
            
            const event = calendar.createEvent(taskName, startDate, endDate, {
              description: `ã‚¿ã‚¹ã‚¯ID: ${taskId}\nã‚·ãƒ¼ãƒˆé€£æº`
            });
            event.addPopupReminder(0);
            
            values[i][COL_EVENT_ID - 1] = event.getId();
            syncCount++;
            idUpdated = true;
          }
        } catch (e) { console.error(`Sync Error: ${e.message}`); }
      }
    }
  }

  if (idUpdated) {
    range.setValues(values);
  }

  let moveCount = 0;
  
  for (let i = values.length - 1; i >= 0; i--) {
    const rowData = values[i];
    if (!rowData.some(c => c !== '')) continue;

    const rawProjectName = rowData[COL_PROJECT_NAME - 1];
    const taskName = rowData[COL_TASK_NAME - 1];

    if (rawProjectName && taskName) {
      const projectName = String(rawProjectName).trim();
      
      if (!EXCLUDED_SHEETS.includes(projectName)) {
        const targetSheet = ss.getSheetByName(projectName);
        
        if (targetSheet) {
          try {
            const targetRow = 29;
            targetSheet.insertRowBefore(targetRow);
            targetSheet.getRange(targetRow, 1, 1, rowData.length).setValues([rowData]);
            taskSheet.deleteRow(TASK_START_ROW + i);
            values.splice(i, 1);
            moveCount++;
          } catch (e) { console.error(`Move Error: ${e.message}`); }
        }
      }
    }
  }

  sortAndWriteBack(taskSheet, TASK_START_ROW, values);

  let msg = `å®Œäº†: `;
  if (syncCount > 0) msg += `${syncCount}ä»¶åŒæœŸ, `;
  if (moveCount > 0) msg += `${moveCount}ä»¶è»¢é€, `;
  msg += `ä¸¦ã³æ›¿ãˆã¾ã—ãŸ`;
  ss.toast(msg, 'å®Œäº†');
}

function syncAndSortProjectSheet(sheet) {
  const ss = SpreadsheetApp.getActiveSpreadsheet();
  const settingsSheet = ss.getSheetByName(SETTING_SHEET_NAME);
  const calendarMap = getCalendarMap(settingsSheet);

  const lastRow = sheet.getLastRow();
  if (lastRow < PROJECT_TASK_START_ROW) {
    ss.toast('å‡¦ç†å¯¾è±¡ã®ã‚¿ã‚¹ã‚¯ãŒã‚ã‚Šã¾ã›ã‚“', 'å®Œäº†');
    return;
  }
  
  const numRows = lastRow - PROJECT_TASK_START_ROW + 1;
  const range = sheet.getRange(PROJECT_TASK_START_ROW, 1, numRows, TASK_AREA_LAST_COL);
  let values = range.getValues();

  // --- é«˜é€ŸåŒ–ã®ãŸã‚ã®ã‚«ãƒ¬ãƒ³ãƒ€ãƒ¼ã‚¤ãƒ™ãƒ³ãƒˆä¸€æ‹¬å–å¾— (å‰å¾Œ2ãƒ¶æœˆç¨‹åº¦) ---
  const startTimeWindow = new Date();
  startTimeWindow.setMonth(startTimeWindow.getMonth() - 2);
  const endTimeWindow = new Date();
  endTimeWindow.setMonth(endTimeWindow.getMonth() + 4); 

  // ã‚«ãƒ¬ãƒ³ãƒ€ãƒ¼ã”ã¨ã®ã‚¤ãƒ™ãƒ³ãƒˆã‚­ãƒ£ãƒƒã‚·ãƒ¥ { calendarId: { eventId: CalendarEvent } }
  const calendarCache = {};

  let syncCount = 0;
  let updateCount = 0;

  for (let i = 0; i < values.length; i++) {
    const rowData = values[i];
    if (!rowData.some(c => c !== '')) continue;

    const [taskName, startTime, duration, priority, unused, unused2, unused3, unused4, calType, eventId, taskId] = rowData;
    // ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ç¢ºèª:
    // 0: A(Check) - unused
    // 1: B(NAME) - taskName (COL_TASK_NAME=2) -> index 1
    // 2: C(START) - startTime (COL_START_TIME=3) -> index 2
    // 3: D(PRI) - priority (COL_PRIORITY=4) -> index 3
    // 4: E(DUR) - duration (COL_DURATION=5) -> index 4
    // 5: F(PROJ) - unused
    // 6: G - unused
    // 7: H - unused
    // 8: I(Type) - calType (COL_CAL_TYPE=9) -> index 8
    // 9: J(EvID) - eventId (COL_EVENT_ID=10) -> index 9
    // 10: K(TID) - taskId (COL_TASK_ID=11) -> index 10

    // æ­£ã—ã„ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ã§ã®å–å¾—
    const tName = rowData[COL_TASK_NAME - 1];
    const tStart = rowData[COL_START_TIME - 1];
    const tDur = rowData[COL_DURATION - 1];
    const tType = rowData[COL_CAL_TYPE - 1];
    const tEvId = rowData[COL_EVENT_ID - 1];
    let tId = rowData[COL_TASK_ID - 1];

    // IDè‡ªå‹•ç”Ÿæˆ
    if (!tId && tName) {
      tId = Utilities.getUuid().split('-')[0];
      rowData[COL_TASK_ID - 1] = tId;
    }

    if (tName && tStart && tType && calendarMap[tType]) {
      const calId = calendarMap[tType];
      
      try {
        const cal = CalendarApp.getCalendarById(calId);
        if (cal) {
          const startDate = new Date(tStart);
          const endDate = new Date(startDate);
          const d = Number(tDur) || 30;
          endDate.setMinutes(endDate.getMinutes() + d);

          if (!tEvId) {
            // --- æ–°è¦ç™»éŒ² ---
            const ev = cal.createEvent(tName, startDate, endDate, { 
              description: `ã‚¿ã‚¹ã‚¯ID: ${tId}\nã‚·ãƒ¼ãƒˆé€£æº` 
            });
            ev.addPopupReminder(0);
            rowData[COL_EVENT_ID - 1] = ev.getId();
            syncCount++;
          } else {
            // --- æ›´æ–°ç¢ºèª (å·®åˆ†æ›´æ–°) ---
            // æ¯å› getEventById ã™ã‚‹ã¨é…ã„ã®ã§ã€å¿…è¦ãªå ´åˆã®ã¿å–å¾—ã™ã‚‹ã‹ã€ã‚­ãƒ£ãƒƒã‚·ãƒ¥åˆ©ç”¨ã‚’æ¤œè¨
            // ã“ã“ã§ã¯ç°¡æ˜“çš„ã«ç›´ã‚¢ã‚¯ã‚»ã‚¹ã™ã‚‹ãŒã€æ¡ä»¶åˆ¤å®šã§APIã‚³ãƒ¼ãƒ«ã‚’æ¸›ã‚‰ã™
            // (GASã®CalendarApp.getEventByIdã¯æ¯”è¼ƒçš„è»½é‡ã ãŒã€å›æ•°ãŒå¤šã„ã¨é…ã„ã€‚
            //  å³å¯†ãªé«˜é€ŸåŒ–ãªã‚‰æœŸé–“æŒ‡å®šã§å…¨å–å¾—ã—ã¦MapåŒ–ã™ã‚‹æ‰‹æ³•ãŒè‰¯ã„ãŒã€
            //  ã¾ãšã¯ã€Œå¤‰æ›´æ™‚ã®ã¿ setTimeã€ã™ã‚‹ãƒ­ã‚¸ãƒƒã‚¯ã«ã™ã‚‹ã ã‘ã§ã‚‚ååˆ†é€Ÿã„)
            
            try {
               // æ—¢å­˜ã‚¤ãƒ™ãƒ³ãƒˆã‚’å–å¾—ã—ã¦å†…å®¹ã‚’ç¢ºèª
               const ev = cal.getEventById(tEvId);
               if (ev) {
                 const evStart = ev.getStartTime();
                 const evEnd = ev.getEndTime();
                 const evNote = ev.getDescription();

                 let needUpdate = false;

                 // æ™‚é–“ã®ã‚ºãƒ¬ãŒ1åˆ†ä»¥ä¸Šã‚ã‚‹ã‹
                 if (Math.abs(evStart.getTime() - startDate.getTime()) > 60000) needUpdate = true;
                 
                 // çµ‚äº†æ™‚é–“ã®ãƒã‚§ãƒƒã‚¯
                 if (Math.abs(evEnd.getTime() - endDate.getTime()) > 60000) needUpdate = true;
                 
                 // ã‚¿ã‚¤ãƒˆãƒ«ã®ãƒã‚§ãƒƒã‚¯ (å¿…è¦ã§ã‚ã‚Œã°)
                 // if (ev.getTitle() !== tName) { ev.setTitle(tName); updateCount++; }

                 if (needUpdate) {
                   ev.setTime(startDate, endDate);
                   updateCount++;
                 }
               }
            } catch(e) {
               console.warn(`Event update failed: ${tEvId}`, e);
            }
          }
        }
      } catch (e) { console.error(e); }
    }
  }

  // ä¸¦ã³æ›¿ãˆã¨æ›¸ãæˆ»ã—
  sortAndWriteBack(sheet, PROJECT_TASK_START_ROW, values);

  let msg = [];
  if (syncCount > 0) msg.push(`${syncCount}ä»¶æ–°è¦ç™»éŒ²`);
  if (updateCount > 0) msg.push(`${updateCount}ä»¶æ›´æ–°`);
  msg.push(`ä¸¦ã³æ›¿ãˆå®Œäº†`);
  ss.toast(msg.join(', '), 'å®Œäº†');
}

function sortAndWriteBack(sheet, startRow, values) {
  const withDate = [];
  const withoutDate = [];

  for (let i = 0; i < values.length; i++) {
    const rowData = values[i];
    if (!rowData.some(c => c !== '')) continue;

    const startTime = rowData[COL_START_TIME - 1];
    if (startTime instanceof Date && !isNaN(startTime)) {
      withDate.push(rowData);
    } else {
      withoutDate.push(rowData);
    }
  }

  const priorityMap = { 'ç·Šæ€¥': 4, 'é«˜ã„': 3, 'ä¸­': 2, 'ä½ã„': 1 };
  const getPriorityScore = (p) => priorityMap[p] || 0;

  const sortFunc = (a, b) => {
    const priA = getPriorityScore(a[COL_PRIORITY - 1]);
    const priB = getPriorityScore(b[COL_PRIORITY - 1]);
    const durA = Number(a[COL_DURATION - 1]) || 0;
    const durB = Number(b[COL_DURATION - 1]) || 0;
    if (priA !== priB) return priB - priA; 
    return durA - durB;
  };

  withDate.sort((a, b) => {
    const dateA = a[COL_START_TIME - 1].getTime();
    const dateB = b[COL_START_TIME - 1].getTime();
    if (dateA !== dateB) return dateA - dateB; 
    return sortFunc(a, b);
  });
  withoutDate.sort(sortFunc);

  const emptyRow = new Array(TASK_AREA_LAST_COL).fill('');
  let resultValues = [];
  if (withDate.length > 0) resultValues = resultValues.concat(withDate);
  if (withoutDate.length > 0) resultValues = resultValues.concat(withoutDate);

  const currentLastRow = sheet.getLastRow();
  const rowsToClear = Math.max(currentLastRow - startRow + 1, values.length);
  if (rowsToClear > 0) {
    sheet.getRange(startRow, 1, rowsToClear, TASK_AREA_LAST_COL).clearContent();
  }
  
  if (resultValues.length > 0) {
    sheet.getRange(startRow, 1, resultValues.length, TASK_AREA_LAST_COL).setValues(resultValues);
  }
}

/**
 * ã‚«ãƒ¬ãƒ³ãƒ€ãƒ¼ã‹ã‚‰Inboxã¸å–è¾¼ (é‡è¤‡ãƒã‚§ãƒƒã‚¯ä»˜ã)
 */
function importCalendarToInbox(settingsSheet, row) {
  const ss = SpreadsheetApp.getActiveSpreadsheet();
  let inboxSheet = ss.getSheetByName(CALENDAR_INBOX_SHEET_NAME);

  // ã‚·ãƒ¼ãƒˆãŒãªã‘ã‚Œã°ä½œæˆ (ã‚¿ã‚¹ã‚¯å…¥åŠ›ã‚·ãƒ¼ãƒˆã‚’ã‚³ãƒ”ãƒ¼æ¨å¥¨ã ãŒã€ç°¡æ˜“ä½œæˆ)
  if (!inboxSheet) {
    const templateSheet = ss.getSheetByName(TASK_SHEET_NAME); // ã‚¿ã‚¹ã‚¯å…¥åŠ›ã‚’ãƒ†ãƒ³ãƒ—ãƒ¬ã«
    if (templateSheet) {
      inboxSheet = templateSheet.copyTo(ss).setName(CALENDAR_INBOX_SHEET_NAME);
      // ä¸­èº«ã‚¯ãƒªã‚¢
      const lastRow = inboxSheet.getLastRow();
      if (lastRow >= TASK_START_ROW) {
         inboxSheet.getRange(TASK_START_ROW, 1, lastRow - TASK_START_ROW + 1, inboxSheet.getLastColumn()).clearContent();
      }
      inboxSheet.getRange('A3').setValue(false).insertCheckbox(); // å®Ÿè¡Œãƒœã‚¿ãƒ³ (A3)
      inboxSheet.getRange('B3').setValue('ã‚¿ã‚¹ã‚¯æŒ¯ã‚Šåˆ†ã‘');       // ãƒ©ãƒ™ãƒ« (B3)
      // ä»–ã®ä½™è¨ˆãªãƒã‚§ãƒƒã‚¯ãƒœãƒƒã‚¯ã‚¹ç­‰ã¯å‰Šé™¤
      inboxSheet.getRange('A1:B2').clearContent().removeCheckboxes();
    } else {
      inboxSheet = ss.insertSheet(CALENDAR_INBOX_SHEET_NAME);
      // ãƒ˜ãƒƒãƒ€ãƒ¼ç°¡æ˜“ä½œæˆ
      inboxSheet.getRange('A3').insertCheckbox();
      inboxSheet.getRange('B3').setValue('ã‚¿ã‚¹ã‚¯æŒ¯ã‚Šåˆ†ã‘');
      inboxSheet.appendRow(['', '', '', '', '', '', '', '', '', '']); // 1-3è¡Œç›®èª¿æ•´
      inboxSheet.getRange(4, 1, 1, 10).setValues([['', 'ã‚¿ã‚¹ã‚¯å', 'é–‹å§‹æ—¥æ™‚', 'å„ªå…ˆåº¦', 'æ‰€è¦æ™‚é–“', 'ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆå', '', '', 'CalType', 'EventID']]);
    }
  }

  // ã‚«ãƒ¬ãƒ³ãƒ€ãƒ¼IDå–å¾—
  const calIdInfo = getCalendarInfoFromRow(settingsSheet, row);
  if (!calIdInfo.id) {
    ss.toast('æœ‰åŠ¹ãªã‚«ãƒ¬ãƒ³ãƒ€ãƒ¼IDãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“', 'ã‚¨ãƒ©ãƒ¼');
    return;
  }
  
  const calName = calIdInfo.name;
  const calId = calIdInfo.id;
  const cal = CalendarApp.getCalendarById(calId);
  if (!cal) {
    ss.toast(`ã‚«ãƒ¬ãƒ³ãƒ€ãƒ¼å–å¾—å¤±æ•—: ${calId}`, 'ã‚¨ãƒ©ãƒ¼');
    return;
  }

  // é‡è¤‡ãƒã‚§ãƒƒã‚¯ç”¨IDãƒªã‚¹ãƒˆåé›†
  const existingEventIds = new Set();
  const allSheets = ss.getSheets();
  const targetSheetNames = [TASK_SHEET_NAME, CALENDAR_INBOX_SHEET_NAME, ...allSheets.map(s => s.getName()).filter(n => !EXCLUDED_SHEETS.includes(n))];
  
  targetSheetNames.forEach(sName => {
     const s = ss.getSheetByName(sName);
     if (!s) return;
     const startR = (sName === TASK_SHEET_NAME || sName === CALENDAR_INBOX_SHEET_NAME) ? TASK_START_ROW : PROJECT_TASK_START_ROW;
     const lastR = s.getLastRow();
     if (lastR >= startR) {
        const ids = s.getRange(startR, COL_EVENT_ID, lastR - startR + 1, 1).getValues().flat();
        ids.forEach(id => { if(id) existingEventIds.add(String(id)); });
     }
  });

  // ã‚¤ãƒ™ãƒ³ãƒˆå–å¾— (å‰å¾Œ1é€±é–“? ãƒ¦ãƒ¼ã‚¶è¦æœ›ã¯"1é€±é–“åˆ†" -> ä»Šæ—¥ã‹ã‚‰1é€±é–“ã¨ã™ã‚‹)
  const startTime = new Date();
  startTime.setHours(0,0,0,0);
  const endTime = new Date();
  endTime.setDate(endTime.getDate() + 7);

  const events = cal.getEvents(startTime, endTime);
  const newTasks = [];

  events.forEach(evt => {
    const eid = evt.getId();
    if (existingEventIds.has(eid)) return; // é‡è¤‡ã‚¹ã‚­ãƒƒãƒ—

    const title = evt.getTitle();
    const start = evt.getStartTime();
    const end = evt.getEndTime();
    const duration = Math.round((end.getTime() - start.getTime()) / (1000 * 60));
    
    // [Check, TaskName, Start, Priority, Duration, ProjectName, ..., CalType, EventID]
    // A=1, B=2, C=3, D=4, E=5, F=6, ..., I=9, J=10
    const rowData = new Array(12).fill('');
    rowData[COL_TASK_NAME - 1] = title;
    rowData[COL_START_TIME - 1] = start;
    rowData[COL_DURATION - 1] = duration;
    rowData[COL_CAL_TYPE - 1] = calName; // è¨­å®šã‚·ãƒ¼ãƒˆã®åå‰
    rowData[COL_EVENT_ID - 1] = eid;
    // TaskIDã¯ã¾ã ä½œã‚‰ãªã„ï¼ˆæŒ¯ã‚Šåˆ†ã‘æ™‚ã«ç”Ÿæˆï¼‰
    
    newTasks.push(rowData);
  });

  if (newTasks.length > 0) {
    const startRow = inboxSheet.getLastRow() + 1;
    // TASK_START_ROWä»¥ä¸Šã§ã‚ã‚‹ã“ã¨ã‚’ä¿è¨¼
    const writeRow = Math.max(startRow, TASK_START_ROW);
    inboxSheet.getRange(writeRow, 1, newTasks.length, newTasks[0].length).setValues(newTasks);
    ss.toast(`${newTasks.length}ä»¶ã®äºˆå®šã‚’å–ã‚Šè¾¼ã¿ã¾ã—ãŸ`, 'å®Œäº†');
  } else {
    ss.toast('æ–°è¦ã®äºˆå®šã¯ã‚ã‚Šã¾ã›ã‚“ã§ã—ãŸ', 'å®Œäº†');
  }
}

/**
 * Inboxã‚¿ã‚¹ã‚¯ã‚’æŒ¯ã‚Šåˆ†ã‘
 */
function distributeInboxTasks() {
  const ss = SpreadsheetApp.getActiveSpreadsheet();
  const inboxSheet = ss.getSheetByName(CALENDAR_INBOX_SHEET_NAME);
  if (!inboxSheet) return;

  const lastRow = inboxSheet.getLastRow();
  if (lastRow < TASK_START_ROW) {
    ss.toast('æŒ¯ã‚Šåˆ†ã‘å¯¾è±¡ãŒã‚ã‚Šã¾ã›ã‚“', 'å®Œäº†');
    return;
  }

  const range = inboxSheet.getRange(TASK_START_ROW, 1, lastRow - TASK_START_ROW + 1, TASK_AREA_LAST_COL);
  const values = range.getValues();
  const taskInputSheet = ss.getSheetByName(TASK_SHEET_NAME);
  
  let moveToProjectCount = 0;
  let moveToInputCount = 0;
  const rowsToDelete = [];

  // ä¸‹ã‹ã‚‰å‡¦ç†ã—ã¦å‰Šé™¤ã™ã‚‹ãŸã‚
  for (let i = values.length - 1; i >= 0; i--) {
    const rowData = values[i];
    if (!rowData.some(c => c !== '')) continue; // ç©ºè¡Œã‚¹ã‚­ãƒƒãƒ—

    const taskName = rowData[COL_TASK_NAME - 1];
    if (!taskName) continue; // ã‚¿ã‚¹ã‚¯åãªã—ã¯ç„¡è¦–

    // ã‚¿ã‚¹ã‚¯IDç”Ÿæˆ (ã¾ã ãªã‘ã‚Œã°)
    if (!rowData[COL_TASK_ID - 1]) {
       rowData[COL_TASK_ID - 1] = Utilities.getUuid().split('-')[0];
    }

    const rawProjectName = rowData[COL_PROJECT_NAME - 1];
    const projectName = String(rawProjectName || '').trim();
    let moved = false;

    // 1. ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆåãŒã‚ã‚Šã€ã‹ã¤æœ‰åŠ¹ãªã‚·ãƒ¼ãƒˆãŒã‚ã‚‹å ´åˆ -> ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆã‚·ãƒ¼ãƒˆã¸
    if (projectName && !EXCLUDED_SHEETS.includes(projectName)) {
      const targetSheet = ss.getSheetByName(projectName);
      if (targetSheet) {
        try {
          const targetRow = PROJECT_TASK_START_ROW;
          targetSheet.insertRowBefore(targetRow);
          targetSheet.getRange(targetRow, 1, 1, rowData.length).setValues([rowData]);
          moved = true;
          moveToProjectCount++;
        } catch (e) {
          console.warn(`Move to project failed: ${projectName}`, e);
        }
      }
    }

    // 2. ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆåãŒãªã„ã€ã¾ãŸã¯ã‚·ãƒ¼ãƒˆãŒè¦‹ã¤ã‹ã‚‰ãªã„å ´åˆ -> ã‚¿ã‚¹ã‚¯å…¥åŠ›ã‚·ãƒ¼ãƒˆã¸
    if (!moved && taskInputSheet) {
        try {
          const targetRow = TASK_START_ROW;
          taskInputSheet.insertRowBefore(targetRow);
          taskInputSheet.getRange(targetRow, 1, 1, rowData.length).setValues([rowData]);
          moved = true;
          moveToInputCount++;
        } catch (e) {
          console.warn(`Move to input failed`, e);
        }
    }

    if (moved) {
      // å‰Šé™¤å¯¾è±¡ã¨ã—ã¦ãƒãƒ¼ã‚¯ (Inboxã‹ã‚‰ã¯æ¶ˆã™)
      inboxSheet.deleteRow(TASK_START_ROW + i);
    }
  }

  // ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆã‚·ãƒ¼ãƒˆå´ãƒ»ã‚¿ã‚¹ã‚¯å…¥åŠ›ã‚·ãƒ¼ãƒˆå´ã®ä¸¦ã³æ›¿ãˆã‚’è¡Œã†ã®ãŒç†æƒ³ã ãŒã€
  // ä»¶æ•°ãŒå¤šã„ã¨é‡ããªã‚‹ã®ã§ã€ä»Šå›ã¯ã€Œè»¢é€ã€ã«ç•™ã‚ã‚‹ï¼ˆãƒ¦ãƒ¼ã‚¶ãƒ¼ãŒå„ã‚·ãƒ¼ãƒˆã§æ›´æ–°ãƒœã‚¿ãƒ³ã‚’æŠ¼ã›ã°ä¸¦ã¶ï¼‰
  // ã‚‚ã—è¦æœ›ãŒã‚ã‚Œã°ã“ã“ã§ sortAndWriteBack ã‚’å„ã‚·ãƒ¼ãƒˆã«å¯¾ã—ã¦å‘¼ã¶ã€‚
  
  ss.toast(`${moveToProjectCount}ä»¶ã‚’ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆã¸ã€${moveToInputCount}ä»¶ã‚’ã‚¿ã‚¹ã‚¯å…¥åŠ›ã¸ç§»å‹•ã—ã¾ã—ãŸ`, 'å®Œäº†');
}

/**
 * è¨­å®šã‚·ãƒ¼ãƒˆã®æŒ‡å®šè¡Œã‹ã‚‰ã‚«ãƒ¬ãƒ³ãƒ€ãƒ¼æƒ…å ±ã‚’å–å¾—
 */
function getCalendarInfoFromRow(sheet, row) {
  const name = sheet.getRange(row, SETTINGS_NAME_COL).getValue();
  let id = sheet.getRange(row, SETTINGS_ID_COL).getValue();
  
  if (id && id.includes('calendar.google.com')) {
      const match = id.match(/src=([^&]+)/);
      if (match) id = decodeURIComponent(match[1]);
      else {
        const cidMatch = id.match(/cid=([^&]+)/);
        if (cidMatch) id = decodeURIComponent(cidMatch[1]);
      }
  }
  return { name, id };
}

// ==========================================
// ã€è¿½è¨˜ã€‘ä¸€ç™ºã‚»ãƒƒãƒˆã‚¢ãƒƒãƒ—æ©Ÿèƒ½ï¼ˆå›ºå®šè¨­å®šç‰ˆï¼‰
// ==========================================

/**
 * ç”»åƒã‚„ãƒ­ã‚°ã‹ã‚‰è§£æã—ãŸã€Œæ­£ã—ã„ä½ç½®ã€ã«ãƒã‚§ãƒƒã‚¯ãƒœãƒƒã‚¯ã‚¹ã‚’å¼·åˆ¶å¾©æ´»ã•ã›ã‚‹
 */
function fixLayout() {
  const ss = SpreadsheetApp.getActiveSpreadsheet();

  // 1. è¨­å®šã‚·ãƒ¼ãƒˆ
  const configSheet = ss.getSheetByName('è¨­å®š');
  if (configSheet) {
    // A2:A3
    configSheet.getRange('A2:A3').setDataValidation(
      SpreadsheetApp.newDataValidation().requireCheckbox().build()
    );
  }

  // 2. ã‚¿ã‚¹ã‚¯å…¥åŠ›ã‚·ãƒ¼ãƒˆ
  const inputSheet = ss.getSheetByName('ã‚¿ã‚¹ã‚¯å…¥åŠ›');
  if (inputSheet) {
    // A3 (FALSEå‡¦ç†)
    inputSheet.getRange('A3').setDataValidation(
      SpreadsheetApp.newDataValidation().requireCheckbox().build()
    );
    // A5ä»¥é™ (å®Œäº†ãƒã‚§ãƒƒã‚¯) - æœ€çµ‚è¡Œã¾ã§
    const maxRows = inputSheet.getMaxRows();
    if (maxRows >= 5) {
      const range = inputSheet.getRange(5, 1, maxRows - 4, 1);
      range.setDataValidation(
        SpreadsheetApp.newDataValidation().requireCheckbox().build()
      );
      fixFalseText(range);
    }
  }

  // 3. ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆãƒ†ãƒ³ãƒ—ãƒ¬ãƒ¼ãƒˆ
  const templateSheet = ss.getSheetByName('ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆãƒ†ãƒ³ãƒ—ãƒ¬ãƒ¼ãƒˆ');
  if (templateSheet) {
    // C27 (ä¸è¦ãªã®ã§å‰Šé™¤)
    templateSheet.getRange('C27').clearDataValidations();
    // A27 (â˜…è¿½åŠ )
    templateSheet.getRange('A27').setDataValidation(
      SpreadsheetApp.newDataValidation().requireCheckbox().build()
    );
    // A29ä»¥é™
    const maxRows = templateSheet.getMaxRows();
    if (maxRows >= 29) {
      const range = templateSheet.getRange(29, 1, maxRows - 28, 1);
      range.setDataValidation(
        SpreadsheetApp.newDataValidation().requireCheckbox().build()
      );
      fixFalseText(range);
    }
  }

  // 4. å®Œäº†ã‚¿ã‚¹ã‚¯
  const doneSheet = ss.getSheetByName('å®Œäº†ã‚¿ã‚¹ã‚¯');
  if (doneSheet) {
    const maxRows = doneSheet.getMaxRows();
    if (maxRows >= 2) {
      const range = doneSheet.getRange(2, 1, maxRows - 1, 1);
      range.setDataValidation(
        SpreadsheetApp.newDataValidation().requireCheckbox().build()
      );
      fixFalseText(range);
    }
  }

  // 5. ã‚¿ã‚¹ã‚¯ä¸€è¦§ (â˜…è¿½åŠ )
  const listSheet = ss.getSheetByName('ã‚¿ã‚¹ã‚¯ä¸€è¦§');
  if (listSheet) {
      // D1
      listSheet.getRange('D1').setDataValidation(
          SpreadsheetApp.newDataValidation().requireCheckbox().build()
      );
  }

  // 6. ã‚«ãƒ¬ãƒ³ãƒ€ãƒ¼å–è¾¼ (â˜…è¿½åŠ )
  const calSheet = ss.getSheetByName('ã‚«ãƒ¬ãƒ³ãƒ€ãƒ¼å–è¾¼');
  if (calSheet) {
      // A3
      calSheet.getRange('A3').setDataValidation(
          SpreadsheetApp.newDataValidation().requireCheckbox().build()
      );
      // A5ä»¥é™
      const maxRows = calSheet.getMaxRows();
      if (maxRows >= 5) {
          const range = calSheet.getRange(5, 1, maxRows - 4, 1);
          range.setDataValidation(
            SpreadsheetApp.newDataValidation().requireCheckbox().build()
          );
          fixFalseText(range);
      }
  }

  SpreadsheetApp.getUi().alert("ä¿®å¾©å®Œäº†ï¼šãƒã‚§ãƒƒã‚¯ãƒœãƒƒã‚¯ã‚¹ã‚’æ­£ã—ã„ä½ç½®ã«ä½œæˆã—ã¾ã—ãŸã€‚");
}

/**
 * ç¯„å›²å†…ã® "FALSE" / "TRUE" ã¨ã„ã†æ–‡å­—åˆ—ã‚’ã€æœ¬ç‰©ã®ãƒ–ãƒ¼ãƒ«å€¤(ãƒã‚§ãƒƒã‚¯ãƒœãƒƒã‚¯ã‚¹ç”¨)ã«å¤‰æ›ã™ã‚‹
 */
function fixFalseText(range) {
  const values = range.getValues();
  let changed = false;
  
  const newValues = values.map(row => row.map(cell => {
    if (cell === 'FALSE') {
      changed = true;
      return false;
    }
    if (cell === 'TRUE') {
      changed = true;
      return true;
    }
    return cell;
  }));

  if (changed) {
    range.setValues(newValues);
  }
}